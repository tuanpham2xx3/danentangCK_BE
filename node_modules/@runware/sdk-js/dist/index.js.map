{"version":3,"sources":["../Runware/reconnect.ts","../Runware/types.ts","../Runware/utils.ts","../Runware/async-retry.ts","../Runware/Runware-base.ts","../Runware/Runware-client.ts","../Runware/Runware-server.ts","../Runware/Runware.ts"],"sourcesContent":["// @ts-nocheck\n/*\nReady state constants\nhttps://developer.mozilla.org/en-US/docs/Web/API/WebSocket#Ready_state_constants\n\nCONNECTING 0 The connection is not yet open.\nOPEN       1 The connection is open and ready to communicate.\nCLOSING    2 The connection is in the process of closing.\nCLOSED     3 The connection is closed or couldn't be opened.\n*/\ntype Options = {\n  constructor?: new (url: string, protocols?: string | string[]) => WebSocket;\n  maxReconnectionDelay?: number;\n  minReconnectionDelay?: number;\n  reconnectionDelayGrowFactor?: number;\n  connectionTimeout?: number;\n  maxRetries?: number;\n  debug?: boolean;\n};\n\nconst isWebSocket = (constructor) => constructor && constructor.CLOSING === 2;\n\nconst isGlobalWebSocket = () =>\n  typeof WebSocket !== \"undefined\" && isWebSocket(WebSocket);\n\nconst getDefaultOptions = () =>\n  <Options>{\n    constructor: isGlobalWebSocket() ? WebSocket : null,\n    maxReconnectionDelay: 10000,\n    minReconnectionDelay: 1500,\n    reconnectionDelayGrowFactor: 1.3,\n    connectionTimeout: 4000,\n    maxRetries: Infinity,\n    debug: false,\n  };\n\nconst bypassProperty = (src, dst, name: string) => {\n  Object.defineProperty(dst, name, {\n    get: () => src[name],\n    set: (value) => {\n      src[name] = value;\n    },\n    enumerable: true,\n    configurable: true,\n  });\n};\n\nconst initReconnectionDelay = (config: Options) =>\n  config.minReconnectionDelay + Math.random() * config.minReconnectionDelay;\n\nconst updateReconnectionDelay = (config: Options, previousDelay: number) => {\n  const newDelay = previousDelay * config.reconnectionDelayGrowFactor;\n  return newDelay > config.maxReconnectionDelay\n    ? config.maxReconnectionDelay\n    : newDelay;\n};\n\nconst LEVEL_0_EVENTS = [\"onopen\", \"onclose\", \"onmessage\", \"onerror\"];\n\nconst reassignEventListeners = (ws: WebSocket, oldWs, listeners) => {\n  Object.keys(listeners).forEach((type) => {\n    listeners[type].forEach(([listener, options]) => {\n      ws.addEventListener(type, listener, options);\n    });\n  });\n  if (oldWs) {\n    LEVEL_0_EVENTS.forEach((name) => {\n      ws[name] = oldWs[name];\n    });\n  }\n};\n\nconst ReconnectingWebsocket = function (\n  url: string,\n  protocols?: string | string[],\n  options = <Options>{}\n) {\n  let ws: WebSocket;\n  let connectingTimeout;\n  let reconnectDelay = 0;\n  let retriesCount = 0;\n  let shouldRetry = true;\n  const listeners: any = {};\n\n  // require new to construct\n  if (!(this instanceof ReconnectingWebsocket)) {\n    throw new TypeError(\n      \"Failed to construct 'ReconnectingWebSocket': Please use the 'new' operator\"\n    );\n  }\n\n  // Set config. Not using `Object.assign` because of IE11\n  const config = getDefaultOptions();\n  Object.keys(config)\n    .filter((key) => options.hasOwnProperty(key))\n    .forEach((key) => (config[key] = options[key]));\n\n  if (!isWebSocket(config.constructor)) {\n    throw new TypeError(\n      \"Invalid WebSocket constructor. Set `options.constructor`\"\n    );\n  }\n\n  const log = config.debug\n    ? (...params) => console.log(\"RWS:\", ...params)\n    : () => {};\n\n  /**\n   * Not using dispatchEvent, otherwise we must use a DOM Event object\n   * Deferred because we want to handle the close event before this\n   */\n  const emitError = (code: string, msg: string) =>\n    setTimeout(() => {\n      const err = <any>new Error(msg);\n      err.code = code;\n      if (Array.isArray(listeners.error)) {\n        listeners.error.forEach(([fn]) => fn(err));\n      }\n      if (ws.onerror) {\n        ws.onerror(err);\n      }\n    }, 0);\n\n  const handleClose = () => {\n    log(\"close\");\n    retriesCount++;\n    log(\"retries count:\", retriesCount);\n    if (retriesCount > config.maxRetries) {\n      emitError(\"EHOSTDOWN\", \"Too many failed connection attempts\");\n      return;\n    }\n    if (!reconnectDelay) {\n      reconnectDelay = initReconnectionDelay(config);\n    } else {\n      reconnectDelay = updateReconnectionDelay(config, reconnectDelay);\n    }\n    log(\"reconnectDelay:\", reconnectDelay);\n\n    if (shouldRetry) {\n      setTimeout(connect, reconnectDelay);\n    }\n  };\n\n  const connect = () => {\n    log(\"connect\");\n    const oldWs = ws;\n    ws = new (<any>config.constructor)(url, protocols);\n\n    connectingTimeout = setTimeout(() => {\n      log(\"timeout\");\n      ws.close();\n      emitError(\"ETIMEDOUT\", \"Connection timeout\");\n    }, config.connectionTimeout);\n\n    log(\"bypass properties\");\n    for (let key in ws) {\n      // @todo move to constant\n      if (\n        [\"addEventListener\", \"removeEventListener\", \"close\", \"send\"].indexOf(\n          key\n        ) < 0\n      ) {\n        bypassProperty(ws, this, key);\n      }\n    }\n\n    ws.addEventListener(\"open\", () => {\n      clearTimeout(connectingTimeout);\n      log(\"open\");\n      reconnectDelay = initReconnectionDelay(config);\n      log(\"reconnectDelay:\", reconnectDelay);\n      retriesCount = 0;\n    });\n\n    ws.addEventListener(\"close\", handleClose);\n\n    reassignEventListeners(ws, oldWs, listeners);\n  };\n\n  log(\"init\");\n  connect();\n\n  this.close = (\n    code = 1000,\n    reason = \"\",\n    { keepClosed = false, fastClose = true, delay = 0 } = {}\n  ) => {\n    if (delay) {\n      reconnectDelay = delay;\n    }\n    shouldRetry = !keepClosed;\n\n    ws.close(code, reason);\n\n    if (fastClose) {\n      const fakeCloseEvent = <CloseEvent>{\n        code,\n        reason,\n        wasClean: true,\n      };\n\n      // execute close listeners soon with a fake closeEvent\n      // and remove all close listeners from the WS instance\n      // so they don't get fired on the real close.\n\n      handleClose();\n\n      if (Array.isArray(listeners.close)) {\n        listeners.close.forEach(([listener, options]) => {\n          listener(fakeCloseEvent);\n          ws.removeEventListener(\"close\", listener, options);\n        });\n      }\n\n      if (ws.onclose) {\n        ws.onclose(fakeCloseEvent);\n        ws.onclose = null;\n      }\n    }\n  };\n\n  this.send = (data) => {\n    ws.send(data);\n  };\n\n  this.addEventListener = (\n    type: string,\n    listener: EventListener,\n    options: any\n  ) => {\n    if (Array.isArray(listeners[type])) {\n      if (!listeners[type].some(([l]) => l === listener)) {\n        listeners[type].push([listener, options]);\n      }\n    } else {\n      listeners[type] = [[listener, options]];\n    }\n    ws.addEventListener(type, listener, options);\n  };\n\n  this.removeEventListener = (\n    type: string,\n    listener: EventListener,\n    options: any\n  ) => {\n    if (Array.isArray(listeners[type])) {\n      listeners[type] = listeners[type].filter(([l]) => l !== listener);\n    }\n    ws.removeEventListener(type, listener, options);\n  };\n};\n\nexport = ReconnectingWebsocket;\n","export enum Environment {\n  PRODUCTION = \"PRODUCTION\",\n  DEVELOPMENT = \"DEVELOPMENT\",\n  TEST = \"TEST\",\n}\nexport enum SdkType {\n  CLIENT = \"CLIENT\",\n  SERVER = \"SERVER\",\n}\n\nexport enum ETaskType {\n  IMAGE_INFERENCE = \"imageInference\",\n  IMAGE_UPLOAD = \"imageUpload\",\n  IMAGE_UPSCALE = \"imageUpscale\",\n  IMAGE_BACKGROUND_REMOVAL = \"imageBackgroundRemoval\",\n  PHOTO_MAKER = \"photoMaker\",\n  IMAGE_CAPTION = \"imageCaption\",\n  IMAGE_CONTROL_NET_PRE_PROCESS = \"imageControlNetPreProcess\",\n  IMAGE_MASKING = \"imageMasking\",\n  PROMPT_ENHANCE = \"promptEnhance\",\n  AUTHENTICATION = \"authentication\",\n  MODEL_UPLOAD = \"modelUpload\",\n  MODEL_SEARCH = \"modelSearch\",\n}\n\nexport type RunwareBaseType = {\n  apiKey: string;\n  url?: string;\n  shouldReconnect?: boolean;\n  globalMaxRetries?: number;\n  timeoutDuration?: number;\n};\n\nexport type IOutputType = \"base64Data\" | \"dataURI\" | \"URL\";\nexport type IOutputFormat = \"JPG\" | \"PNG\" | \"WEBP\";\n\nexport interface IImage {\n  taskType: ETaskType;\n  imageUUID: string;\n  inputImageUUID?: string;\n  taskUUID: string;\n  imageURL?: string;\n  imageBase64Data?: string;\n  imageDataURI?: string;\n  NSFWContent?: boolean;\n  cost?: number;\n  seed: number;\n}\n\nexport interface ITextToImage extends IImage {\n  positivePrompt?: string;\n  negativePrompt?: string;\n}\nexport interface IControlNetImage {\n  taskUUID: string;\n  inputImageUUID: string;\n  guideImageUUID: string;\n  guideImageURL?: string;\n  guideImageBase64Data?: string;\n  guideImageDataURI?: string;\n  cost?: number;\n}\n\ninterface ILora {\n  model: string | number;\n  weight: number;\n}\n\nexport enum EControlMode {\n  BALANCED = \"balanced\",\n  PROMPT = \"prompt\",\n  CONTROL_NET = \"controlnet\",\n}\n\nexport type IControlNetGeneral = {\n  model: string;\n  guideImage: string | File;\n  weight?: number;\n  startStep?: number;\n  startStepPercentage?: number;\n  endStep?: number;\n  endStepPercentage?: number;\n  controlMode: EControlMode;\n};\nexport type IControlNetPreprocess = {\n  inputImage: string | File;\n  preProcessorType: EPreProcessorGroup;\n  height?: number;\n  width?: number;\n  outputType?: IOutputType;\n  outputFormat?: IOutputFormat;\n  highThresholdCanny?: number;\n  lowThresholdCanny?: number;\n  includeHandsAndFaceOpenPose?: boolean;\n  includeCost?: boolean;\n  outputQuality?: number;\n\n  customTaskUUID?: string;\n  retry?: number;\n};\n\n// export type IControlNetA = RequireOnlyOne<\n//   IControlNetGeneral,\n//   \"guideImage\" | \"guideImageUnprocessed\"\n// >;\n\n// export type IControlNetCanny = IControlNetA & {\n//   preprocessor: \"canny\";\n//   lowThresholdCanny: Number;\n//   highThresholdCanny: Number;\n//   outputType?: IOutputType;\n// };\n\n// export type IControlNetHandsAndFace = IControlNetA & {\n//   preprocessor: keyof typeof EOpenPosePreProcessor;\n//   includeHandsAndFaceOpenPose: boolean;\n//   outputType?: IOutputType;\n// };\n\nexport type IControlNet = IControlNetGeneral;\n\nexport type IControlNetWithUUID = Omit<IControlNet, \"guideImage\"> & {\n  guideImage?: string;\n};\n\nexport interface IError {\n  error: boolean;\n  errorMessage: string;\n  taskUUID: string;\n}\n\nexport type TPromptWeighting = \"compel\" | \"sdEmbeds\";\n\nexport interface IRequestImage {\n  outputType?: IOutputType;\n  outputFormat?: IOutputFormat;\n  uploadEndpoint?: string;\n  checkNSFW?: boolean;\n  positivePrompt: string;\n  negativePrompt?: string;\n  seedImage?: File | string;\n  maskImage?: File | string;\n  strength?: number;\n  height?: number;\n  width?: number;\n  model: number | string;\n  steps?: number;\n  scheduler?: string;\n  seed?: number;\n  maskMargin?: number;\n  CFGScale?: number;\n  clipSkip?: number;\n  /**\n   * @deprecated The usePromptWeighting should not be used, use promptWeighting instead\n   */\n  usePromptWeighting?: boolean;\n  promptWeighting?: TPromptWeighting;\n  numberResults?: number; // default to 1\n  includeCost?: boolean;\n  outputQuality?: number;\n\n  controlNet?: IControlNet[];\n  lora?: ILora[];\n  embeddings?: IEmbedding[];\n  ipAdapters?: IipAdapter[];\n  outpaint?: IOutpaint;\n  refiner?: IRefiner;\n\n  // imageSize?: number;\n  customTaskUUID?: string;\n  onPartialImages?: (images: IImage[], error?: IError) => void;\n  retry?: number;\n  // gScale?: number;\n}\n\nexport interface IOutpaint {\n  top?: number;\n  bottom?: number;\n  right?: number;\n  left?: number;\n  blur?: number;\n}\nexport interface IEmbedding {\n  model: string;\n  weight: number;\n}\nexport interface IipAdapter {\n  model: string;\n  weight: number;\n  guideImage: string;\n}\n\nexport interface IRefiner {\n  model: string;\n  startStep?: number;\n  startStepPercentage?: number;\n}\nexport interface IRequestImageToText {\n  inputImage?: File | string;\n  includeCost?: boolean;\n  customTaskUUID?: string;\n  retry?: number;\n}\nexport interface IImageToText {\n  taskType: ETaskType;\n  taskUUID: string;\n  text: string;\n  cost?: number;\n}\n\nexport interface IRemoveImageBackground extends IRequestImageToText {\n  outputType?: IOutputType;\n  outputFormat?: IOutputFormat;\n  model: string;\n  settings?: {\n    rgba?: number[];\n    postProcessMask?: boolean;\n    returnOnlyMask?: boolean;\n    alphaMatting?: boolean;\n    alphaMattingForegroundThreshold?: number;\n    alphaMattingBackgroundThreshold?: number;\n    alphaMattingErodeSize?: number;\n  };\n  includeCost?: boolean;\n  outputQuality?: number;\n  retry?: number;\n}\n\nexport interface IRemoveImage {\n  taskType: ETaskType;\n  taskUUID: string;\n  imageUUID: string;\n  inputImageUUID: string;\n  imageURL?: string;\n  imageBase64Data?: string;\n  imageDataURI?: string;\n  cost?: number;\n}\n\nexport interface IPromptEnhancer {\n  promptMaxLength?: number;\n  promptVersions?: number;\n  prompt: string;\n  includeCost?: boolean;\n  customTaskUUID?: string;\n  retry?: number;\n}\n\nexport interface IEnhancedPrompt extends IImageToText {}\n\nexport interface IUpscaleGan {\n  inputImage: File | string;\n  upscaleFactor: number;\n  outputType?: IOutputType;\n  outputFormat?: IOutputFormat;\n  includeCost?: boolean;\n  outputQuality?: number;\n\n  customTaskUUID?: string;\n  retry?: number;\n}\n\nexport type ReconnectingWebsocketProps = {\n  addEventListener: (\n    type: string,\n    listener: EventListener,\n    options: any\n  ) => void;\n  send: (data: any) => void;\n} & WebSocket;\n\nexport type UploadImageType = {\n  imageURL: string;\n  imageUUID: string;\n  taskUUID: string;\n  taskType: ETaskType;\n};\n\nexport type GetWithPromiseCallBackType = ({\n  resolve,\n  reject,\n  intervalId,\n}: {\n  resolve: <T>(value: T) => void;\n  reject: <T>(value: T) => void;\n  intervalId: any;\n}) => boolean | undefined;\n\nexport enum EPreProcessorGroup {\n  \"canny\" = \"canny\",\n  \"depth\" = \"depth\",\n  \"mlsd\" = \"mlsd\",\n  \"normalbae\" = \"normalbae\",\n  \"openpose\" = \"openpose\",\n  \"tile\" = \"tile\",\n  \"seg\" = \"seg\",\n  \"lineart\" = \"lineart\",\n  \"lineart_anime\" = \"lineart_anime\",\n  \"shuffle\" = \"shuffle\",\n  \"scribble\" = \"scribble\",\n  \"softedge\" = \"softedge\",\n}\n\nexport enum EPreProcessor {\n  \"canny\" = \"canny\",\n  \"depth_leres\" = \"depth_leres\",\n  \"depth_midas\" = \"depth_midas\",\n  \"depth_zoe\" = \"depth_zoe\",\n  \"inpaint_global_harmonious\" = \"inpaint_global_harmonious\",\n  \"lineart_anime\" = \"lineart_anime\",\n  \"lineart_coarse\" = \"lineart_coarse\",\n  \"lineart_realistic\" = \"lineart_realistic\",\n  \"lineart_standard\" = \"lineart_standard\",\n  \"mlsd\" = \"mlsd\",\n  \"normal_bae\" = \"normal_bae\",\n\n  \"scribble_hed\" = \"scribble_hed\",\n  \"scribble_pidinet\" = \"scribble_pidinet\",\n  \"seg_ofade20k\" = \"seg_ofade20k\",\n  \"seg_ofcoco\" = \"seg_ofcoco\",\n  \"seg_ufade20k\" = \"seg_ufade20k\",\n  \"shuffle\" = \"shuffle\",\n  \"softedge_hed\" = \"softedge_hed\",\n  \"softedge_hedsafe\" = \"softedge_hedsafe\",\n  \"softedge_pidinet\" = \"softedge_pidinet\",\n  \"softedge_pidisafe\" = \"softedge_pidisafe\",\n  \"tile_gaussian\" = \"tile_gaussian\",\n\n  \"openpose\" = \"openpose\",\n  \"openpose_face\" = \"openpose_face\",\n  \"openpose_faceonly\" = \"openpose_faceonly\",\n  \"openpose_full\" = \"openpose_full\",\n  \"openpose_hand\" = \"openpose_hand\",\n}\n\nexport enum EOpenPosePreProcessor {\n  \"openpose\" = \"openpose\",\n  \"openpose_face\" = \"openpose_face\",\n  \"openpose_faceonly\" = \"openpose_faceonly\",\n  \"openpose_full\" = \"openpose_full\",\n  \"openpose_hand\" = \"openpose_hand\",\n}\n\nexport type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<\n  T,\n  Exclude<keyof T, Keys>\n> &\n  {\n    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;\n  }[Keys];\n\nexport type RequireOnlyOne<T, Keys extends keyof T = keyof T> = Pick<\n  T,\n  Exclude<keyof T, Keys>\n> &\n  {\n    [K in Keys]-?: Required<Pick<T, K>> &\n      Partial<Record<Exclude<Keys, K>, undefined>>;\n  }[Keys];\n\nexport type ListenerType = {\n  key: string;\n  listener: (msg: any) => void;\n  groupKey?: string;\n};\n\nexport interface IAddModelResponse {\n  status: string;\n  message: string;\n  taskUUID: string;\n  air: string;\n  taskType: string;\n}\n\nexport interface IErrorResponse {\n  code: string;\n  message: string;\n  parameter: string;\n  type: string;\n  documentation: string;\n  taskUUID: string;\n  min?: number;\n  max?: number;\n  default?: string | number;\n}\n\nexport type TAddModelBaseType = {\n  air: string;\n  name: string;\n  downloadUrl: string;\n  uniqueIdentifier: string;\n\n  version: string;\n  format: EModelFormat;\n  architecture: EModelArchitecture;\n  heroImageUrl?: string;\n  tags?: string[];\n  shortDescription?: string;\n  comment?: string;\n  private: boolean;\n\n  // Custom parameters\n  customTaskUUID?: string;\n  retry?: number;\n  onUploadStream?: (\n    response?: IAddModelResponse,\n    error?: IErrorResponse\n  ) => void;\n};\n\nexport type TAddModelControlNet = {\n  category: \"controlnet\";\n  conditioning: EModelConditioning;\n} & TAddModelBaseType;\n\nexport type TAddModelCheckPoint = {\n  category: \"checkpoint\";\n  defaultCFGScale?: number;\n  defaultStrength: number;\n  defaultSteps?: number;\n  defaultScheduler?: string;\n  type: EModelType;\n} & TAddModelBaseType;\n\nexport type TAddModelLora = {\n  category: \"lora\";\n  defaultWeight: number;\n  positiveTriggerWords?: string;\n} & TAddModelBaseType;\n\nexport type TAddModel =\n  | TAddModelCheckPoint\n  | TAddModelControlNet\n  | TAddModelLora;\n\nexport type TPhotoMaker = {\n  style: EPhotoMakerEnum;\n  inputImages: string[];\n  outputType?: string;\n  outputFormat?: string;\n  uploadEndpoint?: string;\n  checkNSFW?: boolean;\n  positivePrompt: string;\n  negativePrompt?: string;\n  strength?: number;\n  height: number;\n  width: number;\n  model?: string; // this should be hidden for now cause we have a single model\n  steps?: number;\n  scheduler?: string;\n  seed?: number;\n  CFGScale?: number;\n  clipSkip?: number;\n  numberResults: number;\n  includeCost?: boolean;\n  outputQuality?: number;\n\n  // other options\n  customTaskUUID?: string;\n  retry?: number;\n  onPartialImages?: (images: IImage[], error?: IError) => void;\n};\n\nexport type TPhotoMakerResponse = {\n  taskType: string;\n  taskUUID: string;\n  imageUUID: string;\n  NSFWContent: boolean;\n  cost: number;\n  seed: number;\n  imageURL: string;\n  positivePrompt: string;\n  negativePrompt?: string;\n};\n\nexport enum EModelFormat {\n  safetensors = \"safetensors\",\n  pickletensor = \"pickletensor\",\n}\n\nexport enum EModelArchitecture {\n  flux1d = \"flux1d\",\n  flux1s = \"flux1s\",\n  pony = \"pony\",\n  sdhyper = \"sdhyper\",\n  sd1x = \"sd1x\",\n  sd1xlcm = \"sd1xlcm\",\n  sd3 = \"sd3\",\n  sdxl = \"sdxl\",\n  sdxllcm = \"sdxllcm\",\n  sdxldistilled = \"sdxldistilled\",\n  sdxlhyper = \"sdxlhyper\",\n  sdxllightning = \"sdxllightning\",\n  sdxlturbo = \"sdxlturbo\",\n}\n\nexport enum EModelType {\n  base = \"base\",\n  inpainting = \"inpainting\",\n  pix2pix = \"pix2pix\",\n}\n\nexport enum EModelConditioning {\n  canny = \"canny\",\n  depth = \"depth\",\n  qrcode = \"qrcode\",\n  hed = \"hed\",\n  scrible = \"scrible\",\n  openpose = \"openpose\",\n  seg = \"segmentation\",\n  openmlsd = \"openmlsd\",\n  softedge = \"softedge\",\n  normal = \"normal bae\",\n  shuffle = \"shuffle\",\n  pix2pix = \"pix2pix\",\n  inpaint = \"inpaint\",\n  lineart = \"line art\",\n  sketch = \"sketch\",\n  inpaintdepth = \"inpaint depth\",\n  tile = \"tile\",\n  outfit = \"outfit\",\n  blur = \"blur\",\n  gray = \"gray\",\n  lowquality = \"low quality\",\n}\n\nexport enum EPhotoMakerEnum {\n  NoStyle = \"No style\",\n  Cinematic = \"Cinematic\",\n  DisneyCharacter = \"Disney Character\",\n  DigitalArt = \"Digital Art\",\n  Photographic = \"Photographic\",\n  FantasyArt = \"Fantasy art\",\n  Neonpunk = \"Neonpunk\",\n  Enhance = \"Enhance\",\n  ComicBook = \"Comic book\",\n  Lowpoly = \"Lowpoly\",\n  LineArt = \"Line art\",\n}\n\nexport type TModelSearch = {\n  search?: string;\n  tags?: string[];\n  category?: \"checkpoint\" | \"lora\" | \"controlnet\";\n  type?: string;\n  architecture?: EModelArchitecture;\n  conditioning?: string;\n  visibility?: \"public\" | \"private\" | \"all\";\n  limit?: number;\n  offset?: number;\n\n  // other options\n  customTaskUUID?: string;\n  retry?: number;\n} & { [key: string]: any };\n\nexport type TModel = {\n  air: string;\n  name: string;\n  version: string;\n  category: string;\n  architecture: string;\n  tags: string[];\n  heroImage: string;\n  private: boolean;\n  comment: string;\n\n  // Optionals\n  type?: string;\n  defaultWidth?: number;\n  defaultHeight?: number;\n  defaultSteps?: number;\n  defaultScheduler?: string;\n  defaultCFG?: number;\n  defaultStrength: number;\n  conditioning?: string;\n  positiveTriggerWords?: string;\n} & { [key: string]: any };\n\nexport type TModelSearchResponse = {\n  results: TModel[];\n  taskUUID: string;\n  taskType: string;\n  totalResults: number;\n};\n\nexport type TImageMasking = {\n  model: string;\n  inputImage: string;\n  confidence?: number;\n  maskPadding?: number;\n  maskBlur?: number;\n  outputFormat?: string;\n  outputType?: string;\n  includeCost?: boolean;\n  uploadEndpoint?: string;\n  maxDetections?: number;\n  outputQuality?: number;\n\n  customTaskUUID?: string;\n  retry?: number;\n};\n\nexport type TImageMaskingResponse = {\n  taskType: string;\n  taskUUID: string;\n  maskImageUUID: string;\n\n  detections: [\n    {\n      x_min: number;\n      y_min: number;\n      x_max: number;\n      y_max: number;\n    }\n  ];\n  maskImageURL: string;\n  cost: number;\n};\n\nexport type TServerError = {\n  error: {\n    code: string;\n    message: string;\n    parameter: string;\n    type: string;\n    taskType: string;\n  };\n};\n","import {\n  EPreProcessor,\n  EPreProcessorGroup,\n  Environment,\n  GetWithPromiseCallBackType,\n  IRequestImage,\n} from \"./types\";\nimport { v4 as uuidv4, validate as validateUUID } from \"uuid\";\n\nexport const TIMEOUT_DURATION = 60000; // 120S;\nexport const MINIMUM_TIMEOUT_DURATION = 1000; // 120S;\nconst POLLING_INTERVAL = 100; // 1s;\n\nexport const BASE_RUNWARE_URLS = {\n  [Environment.PRODUCTION]: \"wss://ws-api.runware.ai/v1\",\n  [Environment.TEST]: \"ws://localhost:8080\",\n};\n\nexport const removeFromAray = <T>(col: T[], targetElem: T) => {\n  if (col == null) {\n    return;\n  }\n  let i = col.indexOf(targetElem);\n  if (i === -1) {\n    return;\n  }\n  col.splice(i, 1);\n};\n\nexport const getIntervalWithPromise = (\n  callback: GetWithPromiseCallBackType,\n  {\n    debugKey = \"debugKey\",\n    timeoutDuration = TIMEOUT_DURATION,\n    shouldThrowError = true,\n  }: {\n    debugKey?: string;\n    timeoutDuration?: number;\n    shouldThrowError?: boolean;\n  }\n) => {\n  timeoutDuration =\n    timeoutDuration < MINIMUM_TIMEOUT_DURATION\n      ? MINIMUM_TIMEOUT_DURATION\n      : timeoutDuration;\n\n  return new Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => {\n      if (intervalId) {\n        clearInterval(intervalId);\n        if (shouldThrowError) {\n          reject(`Response could not be received from server for ${debugKey}`);\n        }\n      }\n      clearTimeout(timeoutId);\n      // reject();\n    }, timeoutDuration);\n\n    let intervalId = setInterval(async () => {\n      const shouldClear = callback({ resolve, reject, intervalId });\n      if (shouldClear) {\n        clearInterval(intervalId);\n        clearTimeout(timeoutId);\n      }\n      // resolve(imagesWithSimilarTask); // Resolve the promise with the data\n    }, POLLING_INTERVAL); // Check every 1 second (adjust the interval as needed)\n  });\n};\n\nexport const fileToBase64 = (file: File) =>\n  new Promise((resolve) => {\n    const reader = new FileReader();\n    reader.readAsDataURL(file);\n    reader.onload = function () {\n      resolve(reader.result);\n    };\n  });\n\n// export const getUUID = () => crypto.randomUUID();\nexport const getUUID = () => uuidv4();\n\nexport const isValidUUID = (uuid: string) => validateUUID(uuid);\n\nconst evaluateToBoolean = (...args: any) => [...args].every((e) => !!e);\n\nexport const compact = (value: any, data: any) => (!!value ? data : {});\n\nexport const getPreprocessorType = (\n  processor: EPreProcessor\n): EPreProcessorGroup => {\n  const processorGroup = Object.keys(\n    EPreProcessorGroup\n  ) as EPreProcessorGroup[];\n\n  switch (processor) {\n    case EPreProcessor.canny:\n      return EPreProcessorGroup.canny;\n    // break\n    case EPreProcessor.depth_leres:\n    case EPreProcessor.depth_midas:\n    case EPreProcessor.depth_zoe:\n      return EPreProcessorGroup.depth;\n    // break\n    case EPreProcessor.inpaint_global_harmonious:\n      return EPreProcessorGroup.depth;\n    // break\n    case EPreProcessor.lineart_anime:\n      return EPreProcessorGroup.lineart_anime;\n    // break\n    case EPreProcessor.lineart_coarse:\n    case EPreProcessor.lineart_realistic:\n    case EPreProcessor.lineart_standard:\n      return EPreProcessorGroup.lineart;\n    // break\n    case EPreProcessor.mlsd:\n      return EPreProcessorGroup.mlsd;\n    // break\n    case EPreProcessor.normal_bae:\n      return EPreProcessorGroup.normalbae;\n    // break\n    case EPreProcessor.openpose_face:\n    case EPreProcessor.openpose_faceonly:\n    case EPreProcessor.openpose_full:\n    case EPreProcessor.openpose_hand:\n    case EPreProcessor.openpose:\n      return EPreProcessorGroup.openpose;\n    // break\n    case EPreProcessor.scribble_hed:\n    case EPreProcessor.scribble_pidinet:\n      return EPreProcessorGroup.scribble;\n    // break\n    case EPreProcessor.seg_ofade20k:\n    case EPreProcessor.seg_ofcoco:\n    case EPreProcessor.seg_ufade20k:\n      return EPreProcessorGroup.seg;\n    // break\n    case EPreProcessor.shuffle:\n      return EPreProcessorGroup.shuffle;\n    // break\n    case EPreProcessor.softedge_hed:\n    case EPreProcessor.softedge_hedsafe:\n    case EPreProcessor.softedge_pidinet:\n    case EPreProcessor.softedge_pidisafe:\n      return EPreProcessorGroup.softedge;\n    // break\n    case EPreProcessor.tile_gaussian:\n      return EPreProcessorGroup.tile;\n    // break\n    default:\n      return EPreProcessorGroup.canny;\n  }\n};\n\nexport const accessDeepObject = ({\n  key,\n  data,\n  useZero = true,\n  shouldReturnString = false,\n}: {\n  key: string;\n  data: Record<string, any>;\n  useZero?: boolean;\n  shouldReturnString?: boolean;\n}) => {\n  const splittedKeys = key.split(/\\.|\\[/).map((key) => key.replace(/\\]$/, \"\"));\n\n  const value = splittedKeys.reduce((acc, curr) => {\n    const returnZero = useZero ? 0 : undefined;\n    const currentValue = acc?.[curr];\n\n    if (!currentValue) {\n      return returnZero;\n    }\n    if (Array.isArray(currentValue) && /^\\d+$/.test(curr)) {\n      const index = parseInt(curr, 10);\n      if (index >= 0 && index < currentValue.length) {\n        return (acc[curr] = currentValue[index]);\n      } else {\n        return acc[curr] ?? returnZero;\n      }\n    } else {\n      return acc[curr] ?? returnZero;\n    }\n  }, data || {});\n\n  // if (typeof value === \"object\" && shouldReturnString) {\n  //   return JSON.stringify(value);\n  // }\n  return value ?? {};\n};\n\nexport const delay = (time: number, milliseconds = 1000) => {\n  return new Promise((resolve) => setTimeout(resolve, time * milliseconds));\n};\n\nexport class MockFile {\n  create = function (name: string, size: number, mimeType: string) {\n    name = name || \"mock.txt\";\n    size = size || 1024;\n    mimeType = mimeType || \"plain/txt\";\n\n    var blob: any = new Blob([range(size)], { type: mimeType });\n    blob.lastModifiedDate = new Date();\n    blob.name = name;\n\n    return blob;\n  };\n}\n\nfunction range(count: number) {\n  var output = \"\";\n  for (var i = 0; i < count; i++) {\n    output += \"a\";\n  }\n  return output;\n}\n\nexport const RETRY_SDK_COUNTS = {\n  GLOBAL: 2,\n  REQUEST_IMAGES: 2,\n};\n\nexport const remove1Mutate = (col: any, targetElem: any) => {\n  if (col == null) {\n    return;\n  }\n\n  let i = col.indexOf(targetElem);\n  if (i === -1) {\n    return;\n  }\n  col.splice(i, 1);\n};\n\nexport const removeListener = (listeners: any[], listener: any) => {\n  return listeners.filter((lis) => lis.key !== listener.key);\n};\n\nexport const removeAllKeyListener = ({\n  listeners,\n  key,\n}: {\n  listeners: any[];\n  key: any;\n}) => {\n  return listeners.filter((lis) => lis?.key !== key);\n};\n\nexport enum LISTEN_TO_IMAGES_KEY {\n  REQUEST_IMAGES = \"REQUEST_IMAGES\",\n}\n\nexport const evaluateNonTrue = ({\n  key,\n  value,\n}: {\n  key: string;\n  value: any;\n}) => {\n  if (!!value || value === 0 || value === false) {\n    return { [key]: value };\n  } else {\n    return {};\n  }\n};\n\nexport const getRandomNumber = (min: number, max: number) => {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nexport const getRandomSeed = () => {\n  return getRandomNumber(1, Number.MAX_SAFE_INTEGER);\n};\n","import { delay } from \"./utils\";\n\nexport const asyncRetry = async (\n  apiCall: Function,\n  options: {\n    maxRetries?: number;\n    delayInSeconds?: number;\n    callback?: Function;\n  } = {}\n) => {\n  const { delayInSeconds = 1, callback } = options;\n  let maxRetries = options.maxRetries ?? 1;\n  while (maxRetries) {\n    try {\n      const result = await apiCall();\n      return result; // Return the result if successful\n    } catch (error: any) {\n      callback?.();\n      maxRetries--;\n      if (maxRetries > 0) {\n        await delay(delayInSeconds); // Delay before the next retry\n        await asyncRetry(apiCall, { ...options, maxRetries });\n      } else {\n        throw error; // Throw the error if max retries are reached\n      }\n    }\n  }\n};\n","// @ts-ignore\nimport { asyncRetry } from \"./async-retry\";\nimport {\n  EControlMode,\n  IControlNet,\n  IControlNetWithUUID,\n  IEnhancedPrompt,\n  IError,\n  IImage,\n  IImageToText,\n  IPromptEnhancer,\n  IRemoveImageBackground,\n  IRequestImage,\n  IRequestImageToText,\n  IUpscaleGan,\n  ListenerType,\n  ReconnectingWebsocketProps,\n  RunwareBaseType,\n  SdkType,\n  UploadImageType,\n  ETaskType,\n  IControlNetPreprocess,\n  IControlNetImage,\n  IRemoveImage,\n  ITextToImage,\n  TAddModel,\n  IAddModelResponse,\n  IErrorResponse,\n  TPhotoMaker,\n  TPhotoMakerResponse,\n  TModelSearch,\n  TImageMaskingResponse,\n  TImageMasking,\n  TModelSearchResponse,\n  TServerError,\n} from \"./types\";\nimport {\n  BASE_RUNWARE_URLS,\n  LISTEN_TO_IMAGES_KEY,\n  TIMEOUT_DURATION,\n  accessDeepObject,\n  delay,\n  evaluateNonTrue,\n  fileToBase64,\n  getIntervalWithPromise,\n  getRandomSeed,\n  getUUID,\n  isValidUUID,\n  removeFromAray,\n  removeListener,\n} from \"./utils\";\n\n// let allImages: IImage[] = [];\n\nexport class RunwareBase {\n  _ws: ReconnectingWebsocketProps | any;\n  _listeners: ListenerType[] = [];\n  _apiKey: string;\n  _url?: string;\n  // _globalMessages: any[] = [];\n  _globalMessages: Record<string, any> = {};\n  _globalImages: IImage[] = [];\n  _globalError: IError | undefined;\n  _connectionSessionUUID: string | undefined;\n  _connectionError: TServerError | undefined;\n  _sdkType: SdkType;\n  _shouldReconnect: boolean;\n  _globalMaxRetries: number;\n  _timeoutDuration: number;\n  ensureConnectionUUID: string | null = null;\n\n  constructor({\n    apiKey,\n    url = BASE_RUNWARE_URLS.PRODUCTION,\n    shouldReconnect = true,\n    globalMaxRetries = 2,\n    timeoutDuration = TIMEOUT_DURATION,\n  }: RunwareBaseType) {\n    this._apiKey = apiKey;\n    this._url = url;\n    this._sdkType = SdkType.CLIENT;\n    this._shouldReconnect = shouldReconnect;\n    this._globalMaxRetries = globalMaxRetries;\n    this._timeoutDuration = timeoutDuration;\n  }\n\n  static async initialize(props: RunwareBaseType) {\n    try {\n      const instance = new this(props);\n      await instance.ensureConnection();\n      return instance;\n    } catch (e) {\n      throw e;\n    }\n  }\n\n  protected isWebsocketReadyState = () => this._ws?.readyState === 1;\n\n  // protected addListener({\n  //   lis,\n  //   check,\n  // }: {\n  //   lis: (v: any) => any;\n  //   check: (v: any) => any;\n  //   groupKey?: string;\n  // }): { destroy: Function } {\n  //   this._ws.onmessage = (e: any) => {\n  //     const m = JSON.parse(e.data);\n\n  //     if (m?.error) {\n  //       lis(m);\n  //     } else if (check(m)) {\n  //       lis(m);\n  //     }\n  //   };\n\n  //   return\n  //     destroy: () => {},\n  //   };\n  // }\n\n  protected isInvalidAPIKey = () => {\n    return this._connectionError?.error?.code === \"invalidApiKey\";\n  };\n\n  protected addListener({\n    lis,\n    // check,\n    groupKey,\n    taskUUID,\n  }: {\n    lis: (v: any) => any;\n    // check: ETaskType;\n    groupKey?: string;\n    taskUUID: string;\n  }) {\n    const listener = (msg: {\n      data: any[];\n      errors?: { taskUUID: string; code: string; taskType?: string }[];\n      errorMessage?: string;\n    }) => {\n      const arrayMessage = Array.isArray(msg?.data) ? msg.data : [msg.data];\n\n      const arrayErrors = (msg as any)?.[0]?.errors\n        ? (msg as any)?.[0]?.errors\n        : Array.isArray(msg?.errors)\n        ? msg.errors\n        : [msg.errors];\n\n      const filteredMessage = arrayMessage.filter(\n        (v) => (v?.taskUUID || v?.taskType) === taskUUID\n      );\n\n      const filteredErrors = arrayErrors.filter(\n        (v: any) => (v?.taskUUID || v?.taskType) === taskUUID\n      );\n\n      if (filteredErrors.length) {\n        lis({ error: { ...(arrayErrors[0] ?? {}) } });\n        return;\n      }\n\n      if (filteredMessage.length) {\n        lis({ [taskUUID]: arrayMessage });\n        return;\n      }\n    };\n    const groupListener = { key: taskUUID || getUUID(), listener, groupKey };\n    this._listeners.push(groupListener);\n    const destroy = () => {\n      this._listeners = removeListener(this._listeners, groupListener);\n    };\n\n    return {\n      destroy,\n    };\n  }\n\n  protected connect() {\n    this._ws.onopen = (e: any) => {\n      if (this._connectionSessionUUID) {\n        this.send({\n          taskType: ETaskType.AUTHENTICATION,\n          apiKey: this._apiKey,\n          connectionSessionUUID: this._connectionSessionUUID,\n        });\n      } else {\n        this.send({ apiKey: this._apiKey, taskType: ETaskType.AUTHENTICATION });\n      }\n\n      this.addListener({\n        taskUUID: ETaskType.AUTHENTICATION,\n        lis: (m) => {\n          if (m?.error) {\n            this._connectionError = m;\n            return;\n          }\n          this._connectionSessionUUID =\n            m?.[ETaskType.AUTHENTICATION]?.[0]?.connectionSessionUUID;\n          this._connectionError = undefined;\n        },\n      });\n    };\n\n    this._ws.onmessage = (e: any) => {\n      const data = JSON.parse(e.data);\n      for (const lis of this._listeners) {\n        const result = (lis as any)?.listener?.(data);\n        if (result) return;\n      }\n    };\n\n    this._ws.onclose = (e: any) => {\n      // console.log(\"closing\");\n      // console.log(\"invalid\", this._invalidAPIkey);\n      if (this.isInvalidAPIKey()) {\n        return;\n      }\n    };\n  }\n\n  // We moving to an array format, it make sense to consolidate all request to an array here\n  protected send = (msg: Object) => {\n    this._ws.send(JSON.stringify([msg]));\n  };\n\n  private destroy(lis: any) {\n    removeFromAray(this._listeners, lis);\n  }\n\n  private uploadImage = async (\n    file: File | string\n  ): Promise<UploadImageType | null> => {\n    try {\n      return await asyncRetry(async () => {\n        const taskUUID = getUUID();\n\n        if (typeof file === \"string\" && isValidUUID(file)) {\n          return {\n            imageURL: file,\n            imageUUID: file,\n            taskUUID,\n            taskType: ETaskType.IMAGE_UPLOAD,\n          };\n        }\n\n        const imageBase64 =\n          typeof file === \"string\" ? file : await fileToBase64(file);\n\n        return {\n          imageURL: imageBase64,\n          imageUUID: imageBase64,\n          taskUUID,\n          taskType: ETaskType.IMAGE_UPLOAD,\n        };\n      });\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  private listenToImages({\n    onPartialImages,\n    taskUUID,\n    groupKey,\n    positivePrompt,\n    negativePrompt,\n  }: {\n    taskUUID: string;\n    onPartialImages?: (images: IImage[], error?: any) => void;\n    groupKey: LISTEN_TO_IMAGES_KEY;\n    positivePrompt?: string;\n    negativePrompt?: string;\n  }) {\n    return this.addListener({\n      taskUUID: taskUUID,\n      lis: (m) => {\n        let images = (m?.[taskUUID] as IImage[])?.filter(\n          (img) => img.taskUUID === taskUUID\n        );\n\n        if (m.error) {\n          onPartialImages?.(images, m?.error && m);\n          this._globalError = m;\n        } else {\n          images = images.map((image) => ({\n            ...image,\n            positivePrompt,\n            negativePrompt,\n          }));\n          onPartialImages?.(images, m?.error && m);\n\n          if (this._sdkType === SdkType.CLIENT) {\n            // this._globalImages = [...this._globalImages, ...m.images];\n            this._globalImages = [\n              ...this._globalImages,\n              ...(m?.[taskUUID] ?? []).map((image: IImage) => ({\n                ...image,\n                positivePrompt,\n                negativePrompt,\n              })),\n            ];\n          } else {\n            this._globalImages = [...this._globalImages, ...images];\n          }\n        }\n      },\n      groupKey,\n    });\n  }\n\n  private listenToUpload({\n    onUploadStream,\n    taskUUID,\n  }: {\n    taskUUID: string;\n    onUploadStream?: (\n      addModelResponse?: IAddModelResponse,\n      error?: IErrorResponse\n    ) => void;\n  }) {\n    return this.addListener({\n      taskUUID: taskUUID,\n      lis: (m) => {\n        const error = m?.error;\n\n        const result = m?.[taskUUID]?.[0] as IAddModelResponse;\n        let response = result?.taskUUID === taskUUID ? result : null;\n\n        if (response || error) {\n          onUploadStream?.(response || undefined, error);\n        }\n      },\n    });\n  }\n\n  private globalListener({ taskUUID }: { taskUUID: string }) {\n    return this.addListener({\n      // check: (m) => {\n      //   const value = accessDeepObject({\n      //     key: responseKey,\n      //     data: m,\n      //     useZero: false,\n      //   });\n      //   return !!value;\n      // },\n      // check: responseKey,\n      taskUUID: taskUUID,\n      lis: (m) => {\n        if (m.error) {\n          this._globalMessages[taskUUID] = m;\n          return;\n        }\n\n        const value = accessDeepObject({\n          key: taskUUID,\n          data: m,\n          useZero: false,\n        });\n\n        if (Array.isArray(value)) {\n          value.forEach((v) => {\n            this._globalMessages[v.taskUUID] = [\n              ...(this._globalMessages[v.taskUUID] ?? []),\n              v,\n            ];\n          });\n        } else {\n          this._globalMessages[value.taskUUID] = value;\n        }\n      },\n    });\n  }\n\n  async requestImages(\n    {\n      outputType,\n      outputFormat,\n      uploadEndpoint,\n      checkNSFW,\n      positivePrompt,\n      negativePrompt,\n      seedImage,\n      maskImage,\n      strength,\n      height,\n      width,\n      model,\n      steps,\n      scheduler,\n      seed,\n      CFGScale,\n      clipSkip,\n      usePromptWeighting,\n      promptWeighting,\n      numberResults = 1,\n      onPartialImages,\n      includeCost,\n      customTaskUUID,\n      retry,\n      refiner,\n      maskMargin,\n      outputQuality,\n      controlNet,\n      lora,\n      embeddings,\n      ipAdapters,\n      outpaint,\n    }: // imageSize,\n    // gScale,\n    IRequestImage,\n    moreOptions?: Record<string, any>\n  ): Promise<ITextToImage[] | undefined> {\n    let lis: any = undefined;\n    let requestObject: Record<string, any> | undefined = undefined;\n    let taskUUIDs: string[] = [];\n    let retryCount = 0;\n\n    const totalRetry = retry || this._globalMaxRetries;\n\n    try {\n      await this.ensureConnection();\n\n      let seedImageUUID: string | null = null;\n      let maskImageUUID: string | null = null;\n      let controlNetData: IControlNetWithUUID[] = [];\n\n      if (seedImage) {\n        const uploadedImage = await this.uploadImage(seedImage);\n\n        if (!uploadedImage) return [];\n        seedImageUUID = uploadedImage.imageUUID;\n      }\n      if (maskImage) {\n        const uploadedMaskInitiator = await this.uploadImage(maskImage);\n        if (!uploadedMaskInitiator) return [];\n        maskImageUUID = uploadedMaskInitiator.imageUUID;\n      }\n\n      if (controlNet?.length) {\n        for (let i = 0; i < controlNet.length; i++) {\n          const controlData: IControlNet = controlNet[i];\n          const {\n            endStep,\n            startStep,\n            weight,\n            guideImage,\n            controlMode,\n            startStepPercentage,\n            endStepPercentage,\n            model: controlNetModel,\n          } = controlData;\n\n          const imageUploaded = guideImage\n            ? await this.uploadImage(guideImage as File | string)\n            : null;\n\n          controlNetData.push({\n            guideImage: imageUploaded?.imageUUID,\n            model: controlNetModel,\n            endStep,\n            startStep,\n            weight,\n            ...evaluateNonTrue({\n              key: \"startStepPercentage\",\n              value: startStepPercentage,\n            }),\n            ...evaluateNonTrue({\n              key: \"endStepPercentage\",\n              value: endStepPercentage,\n            }),\n            controlMode: controlMode || EControlMode.CONTROL_NET,\n          });\n        }\n      }\n\n      requestObject = {\n        taskType: ETaskType.IMAGE_INFERENCE,\n        model,\n        positivePrompt: positivePrompt,\n        ...(negativePrompt ? { negativePrompt } : {}),\n        ...(height ? { height } : {}),\n        ...(width ? { width } : {}),\n        numberResults,\n\n        ...(outputType ? { outputType } : {}),\n        ...(outputFormat ? { outputFormat } : {}),\n        ...(uploadEndpoint ? { uploadEndpoint } : {}),\n        ...evaluateNonTrue({ key: \"checkNSFW\", value: checkNSFW }),\n        ...evaluateNonTrue({ key: \"strength\", value: strength }),\n        ...evaluateNonTrue({ key: \"CFGScale\", value: CFGScale }),\n        ...evaluateNonTrue({ key: \"clipSkip\", value: clipSkip }),\n        ...evaluateNonTrue({ key: \"maskMargin\", value: maskMargin }),\n        ...evaluateNonTrue({\n          key: \"usePromptWeighting\",\n          value: usePromptWeighting,\n        }),\n        ...evaluateNonTrue({ key: \"steps\", value: steps }),\n        ...(promptWeighting ? { promptWeighting } : {}),\n        ...(seed ? { seed: seed } : { seed: getRandomSeed() }),\n        ...(scheduler ? { scheduler } : {}),\n        ...(refiner ? { refiner } : {}),\n        ...(outpaint ? { outpaint } : {}),\n        ...evaluateNonTrue({ key: \"includeCost\", value: includeCost }),\n        ...(seedImageUUID ? { seedImage: seedImageUUID } : {}),\n        ...(maskImageUUID ? { maskImage: maskImageUUID } : {}),\n        ...(outputQuality ? { outputQuality } : {}),\n        ...(controlNetData.length ? { controlNet: controlNetData } : {}),\n        ...(lora?.length ? { lora: lora } : {}),\n        ...(embeddings?.length ? { embeddings } : {}),\n        ...(ipAdapters?.length ? { ipAdapters } : {}),\n        ...(moreOptions ?? {}),\n      };\n\n      return await asyncRetry(\n        async () => {\n          retryCount++;\n          lis?.destroy();\n          const imagesWithSimilarTask = this._globalImages.filter((img) =>\n            taskUUIDs.includes(img.taskUUID)\n          );\n\n          const taskUUID = customTaskUUID || getUUID();\n\n          taskUUIDs.push(taskUUID);\n\n          const imageRemaining = numberResults - imagesWithSimilarTask.length;\n\n          const newRequestObject = {\n            ...requestObject,\n            taskUUID: taskUUID,\n            numberResults: imageRemaining,\n          };\n          this.send(newRequestObject);\n\n          lis = this.listenToImages({\n            onPartialImages,\n            taskUUID: taskUUID,\n            groupKey: LISTEN_TO_IMAGES_KEY.REQUEST_IMAGES,\n            positivePrompt,\n            negativePrompt,\n          });\n\n          const promise = await this.getSimilarImages({\n            taskUUID: taskUUIDs,\n            numberResults,\n            lis,\n          });\n\n          lis.destroy();\n\n          return promise;\n        },\n        {\n          maxRetries: totalRetry,\n          callback: () => {\n            lis?.destroy();\n          },\n        }\n      );\n    } catch (e) {\n      if (retryCount >= totalRetry) {\n        return this.handleIncompleteImages({ taskUUIDs, error: e });\n      }\n      throw e;\n    }\n  }\n\n  controlNetPreProcess = async ({\n    inputImage,\n    preProcessorType,\n    height,\n    width,\n    outputType,\n    outputFormat,\n    highThresholdCanny,\n    lowThresholdCanny,\n    includeHandsAndFaceOpenPose,\n    includeCost,\n    outputQuality,\n    customTaskUUID,\n    retry,\n  }: IControlNetPreprocess): Promise<IControlNetImage | null> => {\n    const totalRetry = retry || this._globalMaxRetries;\n    let lis: any = undefined;\n\n    try {\n      return await asyncRetry(\n        async () => {\n          await this.ensureConnection();\n          const image = await this.uploadImage(inputImage);\n          if (!image?.imageUUID) return null;\n\n          const taskUUID = customTaskUUID || getUUID();\n          this.send({\n            inputImage: image.imageUUID,\n            taskType: ETaskType.IMAGE_CONTROL_NET_PRE_PROCESS,\n            taskUUID,\n            preProcessorType,\n            ...evaluateNonTrue({ key: \"height\", value: height }),\n            ...evaluateNonTrue({ key: \"width\", value: width }),\n            ...evaluateNonTrue({ key: \"outputType\", value: outputType }),\n            ...evaluateNonTrue({ key: \"outputFormat\", value: outputFormat }),\n            ...evaluateNonTrue({ key: \"includeCost\", value: includeCost }),\n            ...evaluateNonTrue({\n              key: \"highThresholdCanny\",\n              value: highThresholdCanny,\n            }),\n            ...evaluateNonTrue({\n              key: \"lowThresholdCanny\",\n              value: lowThresholdCanny,\n            }),\n            ...evaluateNonTrue({\n              key: \"includeHandsAndFaceOpenPose\",\n              value: includeHandsAndFaceOpenPose,\n            }),\n            ...(outputQuality ? { outputQuality } : {}),\n          });\n          lis = this.globalListener({\n            taskUUID,\n          });\n\n          const guideImage = (await getIntervalWithPromise(\n            ({ resolve, reject }) => {\n              const uploadedImage = this.getSingleMessage({\n                taskUUID,\n              });\n\n              if (!uploadedImage) return;\n\n              if (uploadedImage?.error) {\n                reject(uploadedImage);\n                return true;\n              }\n\n              if (uploadedImage) {\n                // delete this._globalMessages[taskUUID];\n                resolve(uploadedImage);\n                return true;\n              }\n            },\n            {\n              debugKey: \"unprocessed-image\",\n              timeoutDuration: this._timeoutDuration,\n            }\n          )) as IControlNetImage;\n\n          lis.destroy();\n\n          return guideImage;\n        },\n        {\n          maxRetries: totalRetry,\n          callback: () => {\n            lis?.destroy();\n          },\n        }\n      );\n    } catch (e: any) {\n      throw e;\n    }\n  };\n\n  requestImageToText = async ({\n    inputImage,\n    includeCost,\n    customTaskUUID,\n    retry,\n  }: IRequestImageToText): Promise<IImageToText> => {\n    const totalRetry = retry || this._globalMaxRetries;\n    let lis: any = undefined;\n\n    try {\n      return await asyncRetry(\n        async () => {\n          await this.ensureConnection();\n          const imageUploaded = inputImage\n            ? await this.uploadImage(inputImage as File | string)\n            : null;\n\n          const taskUUID = customTaskUUID || getUUID();\n          this.send({\n            taskUUID,\n            taskType: ETaskType.IMAGE_CAPTION,\n            inputImage: imageUploaded?.imageUUID,\n            ...evaluateNonTrue({ key: \"includeCost\", value: includeCost }),\n          });\n\n          lis = this.globalListener({\n            taskUUID,\n          });\n\n          const response = await getIntervalWithPromise(\n            ({ resolve, reject }) => {\n              const newReverseClip = this.getSingleMessage({\n                taskUUID,\n              });\n\n              if (!newReverseClip) return;\n\n              if (newReverseClip?.error) {\n                reject(newReverseClip);\n                return true;\n              }\n\n              if (newReverseClip) {\n                delete this._globalMessages[taskUUID];\n                resolve(newReverseClip);\n                return true;\n              }\n            },\n            {\n              debugKey: \"remove-image-background\",\n              timeoutDuration: this._timeoutDuration,\n            }\n          );\n\n          lis.destroy();\n\n          return response as IImageToText;\n        },\n        {\n          maxRetries: totalRetry,\n          callback: () => {\n            lis?.destroy();\n          },\n        }\n      );\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  removeImageBackground = async (\n    payload: IRemoveImageBackground\n  ): Promise<IRemoveImage> => {\n    return this.baseSingleRequest({\n      payload: {\n        ...payload,\n        taskType: ETaskType.IMAGE_BACKGROUND_REMOVAL,\n      },\n      debugKey: \"remove-image-background\",\n    });\n\n    // const totalRetry = retry || this._globalMaxRetries;\n    // let lis: any = undefined;\n\n    // try {\n    //   return await asyncRetry(\n    //     async () => {\n    //       await this.ensureConnection();\n    //       const imageUploaded = inputImage\n    //         ? await this.uploadImage(inputImage as File | string)\n    //         : null;\n\n    //       const taskUUID = customTaskUUID || getUUID();\n\n    //       this.send({\n    //         taskType: ETaskType.IMAGE_BACKGROUND_REMOVAL,\n    //         taskUUID,\n    //         inputImage: imageUploaded?.imageUUID,\n    //         ...evaluateNonTrue({ key: \"rgba\", value: rgba }),\n    //         ...evaluateNonTrue({\n    //           key: \"postProcessMask\",\n    //           value: postProcessMask,\n    //         }),\n    //         ...evaluateNonTrue({\n    //           key: \"returnOnlyMask\",\n    //           value: returnOnlyMask,\n    //         }),\n    //         ...evaluateNonTrue({ key: \"alphaMatting\", value: alphaMatting }),\n    //         ...evaluateNonTrue({ key: \"includeCost\", value: includeCost }),\n    //         ...evaluateNonTrue({\n    //           key: \"alphaMattingForegroundThreshold\",\n    //           value: alphaMattingForegroundThreshold,\n    //         }),\n    //         ...evaluateNonTrue({\n    //           key: \"alphaMattingBackgroundThreshold\",\n    //           value: alphaMattingBackgroundThreshold,\n    //         }),\n    //         ...evaluateNonTrue({\n    //           key: \"alphaMattingErodeSize\",\n    //           value: alphaMattingErodeSize,\n    //         }),\n    //         ...evaluateNonTrue({ key: \"outputType\", value: outputType }),\n    //         ...evaluateNonTrue({ key: \"outputFormat\", value: outputFormat }),\n    //         ...(outputQuality ? { outputQuality } : {}),\n    //       });\n\n    //       lis = this.globalListener({\n    //         taskUUID,\n    //       });\n\n    //       const response = await getIntervalWithPromise(\n    //         ({ resolve, reject }) => {\n    //           const newRemoveBackground = this.getSingleMessage({ taskUUID });\n\n    //           if (!newRemoveBackground) return;\n\n    //           if (newRemoveBackground?.error) {\n    //             reject(newRemoveBackground);\n    //             return true;\n    //           }\n\n    //           if (newRemoveBackground) {\n    //             delete this._globalMessages[taskUUID];\n    //             resolve(newRemoveBackground);\n    //             return true;\n    //           }\n    //         },\n    //         {\n    //           debugKey: \"remove-image-background\",\n    //           timeoutDuration: this._timeoutDuration,\n    //         }\n    //       );\n\n    //       lis.destroy();\n\n    //       return response as IImage;\n    //     },\n    //     {\n    //       maxRetries: totalRetry,\n    //       callback: () => {\n    //         lis?.destroy();\n    //       },\n    //     }\n    //   );\n    // } catch (e) {\n    //   throw e;\n    // }\n  };\n\n  upscaleGan = async ({\n    inputImage,\n    upscaleFactor,\n    outputType,\n    outputFormat,\n    includeCost,\n    outputQuality,\n    customTaskUUID,\n    retry,\n  }: IUpscaleGan): Promise<IImage> => {\n    const totalRetry = retry || this._globalMaxRetries;\n    let lis: any = undefined;\n\n    try {\n      return await asyncRetry(\n        async () => {\n          await this.ensureConnection();\n          let imageUploaded;\n\n          imageUploaded = await this.uploadImage(inputImage as File | string);\n\n          const taskUUID = customTaskUUID || getUUID();\n\n          this.send({\n            taskUUID,\n            inputImage: imageUploaded?.imageUUID,\n            taskType: ETaskType.IMAGE_UPSCALE,\n            upscaleFactor,\n            ...evaluateNonTrue({ key: \"includeCost\", value: includeCost }),\n            ...(outputType ? { outputType } : {}),\n            ...(outputQuality ? { outputQuality } : {}),\n            ...(outputFormat ? { outputFormat } : {}),\n          });\n\n          lis = this.globalListener({\n            taskUUID,\n          });\n\n          const response = await getIntervalWithPromise(\n            ({ resolve, reject }) => {\n              const newUpscaleGan = this.getSingleMessage({ taskUUID });\n              if (!newUpscaleGan) return;\n\n              if (newUpscaleGan?.error) {\n                reject(newUpscaleGan);\n                return true;\n              }\n\n              if (newUpscaleGan) {\n                delete this._globalMessages[taskUUID];\n                resolve(newUpscaleGan);\n                return true;\n              }\n            },\n            { debugKey: \"upscale-gan\", timeoutDuration: this._timeoutDuration }\n          );\n\n          lis.destroy();\n\n          return response as IImage;\n        },\n        {\n          maxRetries: totalRetry,\n          callback: () => {\n            lis?.destroy();\n          },\n        }\n      );\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  enhancePrompt = async ({\n    prompt,\n    promptMaxLength = 380,\n    promptVersions = 1,\n    includeCost,\n    customTaskUUID,\n    retry,\n  }: IPromptEnhancer): Promise<IEnhancedPrompt[]> => {\n    const totalRetry = retry || this._globalMaxRetries;\n    let lis: any = undefined;\n\n    try {\n      return await asyncRetry(\n        async () => {\n          await this.ensureConnection();\n          const taskUUID = customTaskUUID || getUUID();\n\n          this.send({\n            prompt,\n            taskUUID,\n            promptMaxLength,\n            promptVersions,\n            ...evaluateNonTrue({ key: \"includeCost\", value: includeCost }),\n            taskType: ETaskType.PROMPT_ENHANCE,\n          });\n\n          lis = this.globalListener({\n            taskUUID,\n          });\n\n          const response = await getIntervalWithPromise(\n            ({ resolve, reject }) => {\n              const reducedPrompt: IEnhancedPrompt[] =\n                this._globalMessages[taskUUID];\n\n              if ((reducedPrompt as any)?.error) {\n                reject(reducedPrompt as any);\n                return true;\n              }\n\n              if (reducedPrompt?.length >= promptVersions) {\n                delete this._globalMessages[taskUUID];\n                resolve(reducedPrompt);\n                return true;\n              }\n            },\n            {\n              debugKey: \"enhance-prompt\",\n              timeoutDuration: this._timeoutDuration,\n            }\n          );\n\n          lis.destroy();\n          return response as IEnhancedPrompt[];\n        },\n        {\n          maxRetries: totalRetry,\n          callback: () => {\n            lis?.destroy();\n          },\n        }\n      );\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  modelUpload = async (payload: TAddModel) => {\n    // This is written to destructure the payload from the additional parameters\n    const { onUploadStream, retry, customTaskUUID, ...addModelPayload } =\n      payload;\n\n    const totalRetry = retry || this._globalMaxRetries;\n    let lis: any = undefined;\n\n    try {\n      return await asyncRetry(\n        async () => {\n          await this.ensureConnection();\n          const taskUUID = customTaskUUID || getUUID();\n\n          this.send({\n            ...addModelPayload,\n            taskUUID,\n            taskType: ETaskType.MODEL_UPLOAD,\n          });\n\n          let result: IAddModelResponse;\n          let errorResult: IErrorResponse;\n\n          lis = this.listenToUpload({\n            taskUUID,\n            onUploadStream: (response, error) => {\n              onUploadStream?.(response, error);\n              if (response?.status === \"ready\") {\n                result = response;\n              } else if (error) {\n                errorResult = error;\n              }\n            },\n          });\n\n          const modelUploadResponse = await getIntervalWithPromise(\n            ({ resolve, reject }) => {\n              if (result) {\n                resolve(result);\n                return true;\n              } else if (errorResult) {\n                reject(errorResult);\n                return false;\n              }\n            },\n            {\n              shouldThrowError: false,\n              timeoutDuration: 60 * 60 * 1000,\n            }\n          );\n\n          return modelUploadResponse as IAddModelResponse | IErrorResponse;\n        },\n        {\n          maxRetries: totalRetry,\n          callback: () => {\n            lis?.destroy();\n          },\n        }\n      );\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  photoMaker = async (\n    payload: TPhotoMaker,\n    moreOptions?: Record<string, any>\n  ): Promise<TPhotoMakerResponse[] | undefined> => {\n    // This is written to destructure the payload from the additional parameters\n    const {\n      onPartialImages,\n      retry,\n      customTaskUUID,\n      numberResults,\n      ...photoMakerPayload\n    } = payload;\n\n    const totalRetry = retry || this._globalMaxRetries;\n    let lis: any = undefined;\n    let taskUUIDs: string[] = [];\n    let retryCount = 0;\n\n    try {\n      return await asyncRetry(\n        async () => {\n          await this.ensureConnection();\n          retryCount++;\n          const imagesWithSimilarTask = this._globalImages.filter((img) =>\n            taskUUIDs.includes(img.taskUUID)\n          );\n\n          const taskUUID = customTaskUUID || getUUID();\n          taskUUIDs.push(taskUUID);\n\n          const imageRemaining = numberResults - imagesWithSimilarTask.length;\n\n          this.send({\n            ...photoMakerPayload,\n            ...(photoMakerPayload.seed\n              ? { seed: photoMakerPayload.seed }\n              : { seed: getRandomSeed() }),\n            ...(moreOptions ?? {}),\n            numberResults: imageRemaining,\n            taskUUID,\n            taskType: ETaskType.PHOTO_MAKER,\n          });\n\n          lis = this.listenToImages({\n            onPartialImages,\n            taskUUID: taskUUID,\n            groupKey: LISTEN_TO_IMAGES_KEY.REQUEST_IMAGES,\n            positivePrompt: photoMakerPayload.positivePrompt,\n            // negativePrompt: payload.ne,\n          });\n\n          const promise = await this.getSimilarImages({\n            taskUUID: taskUUIDs,\n            numberResults,\n            lis,\n          });\n\n          lis.destroy();\n\n          return promise as TPhotoMakerResponse[];\n        },\n        {\n          maxRetries: totalRetry,\n          callback: () => {\n            lis?.destroy();\n          },\n        }\n      );\n    } catch (e) {\n      if ((e as any).taskUUID) {\n        throw e;\n      }\n      if (retryCount >= totalRetry) {\n        return this.handleIncompleteImages({\n          taskUUIDs,\n          error: e,\n        }) as TPhotoMakerResponse[];\n      }\n    }\n  };\n\n  modelSearch = async (\n    payload: TModelSearch\n  ): Promise<TModelSearchResponse> => {\n    return this.baseSingleRequest({\n      payload: {\n        ...payload,\n        taskType: ETaskType.MODEL_SEARCH,\n      },\n      debugKey: \"model-search\",\n    });\n  };\n\n  imageMasking = async (\n    payload: TImageMasking\n  ): Promise<TImageMaskingResponse> => {\n    return this.baseSingleRequest({\n      payload: {\n        ...payload,\n        taskType: ETaskType.IMAGE_MASKING,\n      },\n      debugKey: \"image-masking\",\n    });\n  };\n\n  protected baseSingleRequest = async <T>({\n    payload,\n    debugKey,\n  }: {\n    payload: Record<string, any>;\n    debugKey: string;\n  }): Promise<T> => {\n    const { retry, customTaskUUID, ...restPayload } = payload;\n\n    const totalRetry = retry || this._globalMaxRetries;\n    let lis: any = undefined;\n\n    try {\n      return await asyncRetry(\n        async () => {\n          await this.ensureConnection();\n          const taskUUID = customTaskUUID || getUUID();\n\n          this.send({\n            ...restPayload,\n            taskUUID,\n          });\n\n          lis = this.globalListener({\n            taskUUID,\n          });\n\n          const response = await getIntervalWithPromise(\n            ({ resolve, reject }) => {\n              const response = this.getSingleMessage({ taskUUID });\n              if (!response) return;\n\n              if (response?.error) {\n                reject(response);\n                return true;\n              }\n\n              if (response) {\n                delete this._globalMessages[taskUUID];\n                resolve(response);\n                return true;\n              }\n            },\n            {\n              debugKey,\n              timeoutDuration: this._timeoutDuration,\n            }\n          );\n\n          lis.destroy();\n          return response as T;\n        },\n        {\n          maxRetries: totalRetry,\n          callback: () => {\n            lis?.destroy();\n          },\n        }\n      );\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  async ensureConnection() {\n    let isConnected = this.connected();\n    if (isConnected || this._url === BASE_RUNWARE_URLS.TEST) return;\n\n    const retryInterval = 2000;\n    const pollingInterval = 200;\n    // const pollingInterval = this._sdkType === SdkType.CLIENT ? 200 : 2000;\n\n    try {\n      if (this.isInvalidAPIKey()) {\n        throw this._connectionError;\n      }\n\n      return new Promise((resolve, reject) => {\n        //  const isConnected =\n        let retry = 0;\n        const MAX_RETRY = 30;\n\n        const localConnectionUUID = getUUID();\n\n        let retryIntervalId: any;\n        let pollingIntervalId: any;\n\n        const clearAllIntervals = () => {\n          this.ensureConnectionUUID = null;\n          clearInterval(retryIntervalId);\n          clearInterval(pollingIntervalId);\n        };\n\n        if (this._sdkType === SdkType.SERVER) {\n          retryIntervalId = setInterval(async () => {\n            try {\n              const hasConnected = this.connected();\n\n              // only one instance should be responsible for making the call again, not other ensureConnection\n              let shouldCallServer = false;\n\n              if (\n                !this.ensureConnectionUUID ||\n                localConnectionUUID === this.ensureConnectionUUID\n              ) {\n                if (!this.ensureConnectionUUID) {\n                  this.ensureConnectionUUID = localConnectionUUID;\n                }\n                shouldCallServer = true;\n              }\n\n              // Retry every (retryInterval % retry) => 60s\n              // every 20 seconds (ie. => retry is 10 (20s), retry is 20 (40s))\n              const SHOULD_RETRY = retry % 10 === 0 && shouldCallServer;\n\n              if (hasConnected) {\n                clearAllIntervals();\n                resolve(true);\n              } else if (retry >= MAX_RETRY) {\n                clearAllIntervals();\n                reject(new Error(\"Retry timed out\"));\n              } else {\n                if (SHOULD_RETRY) {\n                  this.connect();\n                }\n                retry++;\n              }\n            } catch (error) {\n              clearAllIntervals();\n              reject(error);\n            }\n          }, retryInterval);\n        }\n\n        pollingIntervalId = setInterval(async () => {\n          const hasConnected = this.connected();\n\n          if (hasConnected) {\n            clearAllIntervals();\n            resolve(true);\n            return;\n          }\n          if (!!this.isInvalidAPIKey()) {\n            clearAllIntervals();\n            reject(this._connectionError);\n            return;\n          }\n        }, pollingInterval);\n      });\n    } catch (e) {\n      this.ensureConnectionUUID = null;\n      this._connectionError = undefined;\n\n      throw (\n        this._connectionError ??\n        \"Could not connect to server. Ensure your API key is correct\"\n      );\n    }\n  }\n\n  private async getSimilarImages({\n    taskUUID,\n    numberResults,\n    shouldThrowError,\n    lis,\n  }: {\n    taskUUID: string | string[];\n    numberResults: number;\n    shouldThrowError?: boolean;\n    lis: any;\n  }): Promise<IImage[] | IError> {\n    return (await getIntervalWithPromise(\n      ({ resolve, reject, intervalId }) => {\n        const taskUUIDs = Array.isArray(taskUUID) ? taskUUID : [taskUUID];\n        const imagesWithSimilarTask = this._globalImages.filter((img) =>\n          taskUUIDs.includes(img.taskUUID)\n        );\n\n        if (this._globalError) {\n          const newData = this._globalError;\n          this._globalError = undefined;\n          // throw errorData[0]\n          clearInterval(intervalId);\n          reject<IError>?.(newData);\n          return true;\n        }\n        // onPartialImages?.(imagesWithSimilarTask)\n        else if (imagesWithSimilarTask.length >= numberResults) {\n          // lis?.destroy();\n          clearInterval(intervalId);\n          this._globalImages = this._globalImages.filter(\n            (img) => !taskUUIDs.includes(img.taskUUID)\n          );\n          resolve<IImage[]>([...imagesWithSimilarTask].slice(0, numberResults));\n          return true;\n          // Resolve the promise with the data\n        }\n      },\n      {\n        debugKey: \"getting images\",\n        shouldThrowError,\n        timeoutDuration: this._timeoutDuration,\n      }\n    )) as IImage[];\n  }\n\n  private getSingleMessage = ({ taskUUID }: { taskUUID: string }) => {\n    const value = this._globalMessages[taskUUID]?.[0];\n    const errorValue = this._globalMessages[taskUUID];\n    if (!value && !errorValue) return null;\n    return errorValue?.error ? errorValue : value;\n  };\n\n  private handleIncompleteImages({\n    taskUUIDs,\n    error,\n  }: {\n    taskUUIDs: string[];\n    error: any;\n  }) {\n    const imagesWithSimilarTask = this._globalImages.filter((img) =>\n      taskUUIDs.includes(img.taskUUID)\n    );\n    if (imagesWithSimilarTask.length > 1) {\n      this._globalImages = this._globalImages.filter(\n        (img) => !taskUUIDs.includes(img.taskUUID)\n      );\n      return imagesWithSimilarTask;\n    } else {\n      throw error;\n    }\n  }\n\n  disconnect = async () => {\n    this._shouldReconnect = false;\n    this._ws?.terminate?.();\n    this._ws?.close?.();\n  };\n\n  private connected = () =>\n    this.isWebsocketReadyState() && !!this._connectionSessionUUID;\n  //end of data\n}\n","import { RunwareBase } from \"./Runware-base\";\nimport ReconnectingWebsocket from \"./reconnect\";\nimport { ReconnectingWebsocketProps, RunwareBaseType } from \"./types\";\n\nexport class RunwareClient extends RunwareBase {\n  constructor(props: RunwareBaseType) {\n    const { shouldReconnect, ...rest } = props;\n\n    super(rest);\n    this._ws = new (ReconnectingWebsocket as any)(\n      this._url\n    ) as ReconnectingWebsocketProps;\n    this.connect();\n  }\n}\n","// @ts-ignore\n// import ReconnectingWebsocket from \"./reconnect\";\nimport WebSocket from \"ws\";\n\nimport { RunwareBase } from \"./Runware-base\";\nimport { ETaskType, RunwareBaseType, SdkType } from \"./types\";\nimport { delay } from \"./utils\";\n\n// let allImages: IImage[] = [];\n\nexport class RunwareServer extends RunwareBase {\n  _instantiated: boolean = false;\n  _listeners: any[] = [];\n  _reconnectingIntervalId: null | any = null;\n  _pingTimeout: any;\n  _pongListener: any;\n\n  constructor(props: RunwareBaseType) {\n    super(props);\n\n    this._sdkType = SdkType.SERVER;\n    this.connect();\n  }\n\n  // protected addListener({\n  //   lis,\n  //   check,\n  //   groupKey,\n  // }: {\n  //   lis: (v: any) => any;\n  //   check: (v: any) => any;\n  //   groupKey?: string;\n  // }) {\n  //   const listener = (msg: any) => {\n  //     if (msg?.error) {\n  //       lis(msg);\n  //     } else if (check(msg)) {\n  //       lis(msg);\n  //     }\n  //   };\n  //   const groupListener = { key: getUUID(), listener, groupKey };\n  //   this._listeners.push(groupListener);\n  //   const destroy = () => {\n  //     this._listeners = removeListener(this._listeners, groupListener);\n  //   };\n\n  //   return {\n  //     destroy,\n  //   };\n  // }\n\n  protected async connect() {\n    if (!this._url) return;\n\n    this.resetConnection();\n\n    this._ws = new WebSocket(this._url, {\n      perMessageDeflate: false,\n    });\n\n    // delay(1);\n\n    this._ws.on(\"error\", () => {});\n    this._ws.on(\"close\", () => {\n      this.handleClose();\n    });\n\n    this._ws.on(\"open\", () => {\n      if (this._reconnectingIntervalId) {\n        clearInterval(this._reconnectingIntervalId);\n      }\n      if (this._connectionSessionUUID && this.isWebsocketReadyState()) {\n        this.send({\n          taskType: ETaskType.AUTHENTICATION,\n          apiKey: this._apiKey,\n          connectionSessionUUID: this._connectionSessionUUID,\n        });\n      } else {\n        if (this.isWebsocketReadyState()) {\n          this.send({\n            apiKey: this._apiKey,\n            taskType: ETaskType.AUTHENTICATION,\n          });\n        }\n      }\n\n      this.addListener({\n        taskUUID: ETaskType.AUTHENTICATION,\n        lis: (m) => {\n          if (m?.error) {\n            this._connectionError = m;\n            return;\n          }\n          this._connectionSessionUUID =\n            m?.[ETaskType.AUTHENTICATION]?.[0]?.connectionSessionUUID;\n          this._connectionError = undefined;\n        },\n      });\n    });\n\n    this._ws.on(\"message\", (e: any, isBinary: any) => {\n      const data = isBinary ? e : e?.toString();\n      if (!data) return;\n      const m = JSON.parse(data);\n\n      // console.log(\"response\", JSON.stringify(m, null, 4));\n\n      this._listeners.forEach((lis) => {\n        const result = lis.listener(m);\n        if (result) {\n          return;\n        }\n      });\n    });\n  }\n\n  protected send = (msg: Object) => {\n    this._ws.send(JSON.stringify([msg]));\n  };\n\n  protected handleClose() {\n    if (this.isInvalidAPIKey()) {\n      return;\n    }\n    if (this._reconnectingIntervalId) {\n      clearInterval(this._reconnectingIntervalId);\n    }\n\n    if (this._shouldReconnect) {\n      setTimeout(() => this.connect(), 1000);\n    }\n    // this._reconnectingIntervalId = setInterval(() => this.connect(), 1000);\n  }\n\n  protected resetConnection = () => {\n    if (this._ws) {\n      this._listeners.forEach((list) => {\n        list?.destroy?.();\n      });\n      this._ws.removeAllListeners(); // Remove all listeners\n      if (this._ws.readyState === 1) {\n        this._ws.terminate();\n        this._ws.close(); // Attempt to close gracefully\n      }\n\n      this._ws = null;\n      this._listeners = [];\n    }\n  };\n\n  protected heartBeat() {\n    clearTimeout(this._pingTimeout);\n\n    this._pingTimeout = setTimeout(() => {\n      if (this.isWebsocketReadyState()) {\n        this.send({ ping: true });\n      }\n    }, 5000);\n  }\n\n  //end of data\n}\n","// @ts-ignore\nimport { RunwareClient } from \"./Runware-client\";\nimport { RunwareServer } from \"./Runware-server\";\n\nlet Runware: typeof RunwareClient | typeof RunwareServer;\n\nif (typeof window === \"undefined\") {\n  Runware = RunwareServer;\n} else {\n  Runware = RunwareClient;\n}\n\nexport { Runware };\n"],"mappings":"0hBAAA,IAAAA,GAAAC,GAAA,CAAAC,GAAAC,KAAA,cAoBA,IAAMC,GAAeC,GAAgBA,GAAeA,EAAY,UAAY,EAEtEC,GAAoB,IACxB,OAAO,UAAc,KAAeF,GAAY,SAAS,EAErDG,GAAoB,KACf,CACP,YAAaD,GAAkB,EAAI,UAAY,KAC/C,qBAAsB,IACtB,qBAAsB,KACtB,4BAA6B,IAC7B,kBAAmB,IACnB,WAAY,IACZ,MAAO,EACT,GAEIE,GAAiB,CAACC,EAAKC,EAAKC,IAAiB,CACjD,OAAO,eAAeD,EAAKC,EAAM,CAC/B,IAAK,IAAMF,EAAIE,CAAI,EACnB,IAAMC,GAAU,CACdH,EAAIE,CAAI,EAAIC,CACd,EACA,WAAY,GACZ,aAAc,EAChB,CAAC,CACH,EAEMC,GAAyBC,GAC7BA,EAAO,qBAAuB,KAAK,OAAO,EAAIA,EAAO,qBAEjDC,GAA0B,CAACD,EAAiBE,IAA0B,CAC1E,IAAMC,EAAWD,EAAgBF,EAAO,4BACxC,OAAOG,EAAWH,EAAO,qBACrBA,EAAO,qBACPG,CACN,EAEMC,GAAiB,CAAC,SAAU,UAAW,YAAa,SAAS,EAE7DC,GAAyB,CAACC,EAAeC,EAAOC,IAAc,CAClE,OAAO,KAAKA,CAAS,EAAE,QAASC,GAAS,CACvCD,EAAUC,CAAI,EAAE,QAAQ,CAAC,CAACC,EAAUC,CAAO,IAAM,CAC/CL,EAAG,iBAAiBG,EAAMC,EAAUC,CAAO,CAC7C,CAAC,CACH,CAAC,EACGJ,GACFH,GAAe,QAASP,GAAS,CAC/BS,EAAGT,CAAI,EAAIU,EAAMV,CAAI,CACvB,CAAC,CAEL,EAEMe,GAAwB,SAC5BC,EACAC,EACAH,EAAmB,CAAC,EACpB,CACA,IAAIL,EACAS,EACAC,EAAiB,EACjBC,EAAe,EACfC,EAAc,GACZV,EAAiB,CAAC,EAGxB,GAAI,EAAE,gBAAgBI,IACpB,MAAM,IAAI,UACR,4EACF,EAIF,IAAMZ,EAASP,GAAkB,EAKjC,GAJA,OAAO,KAAKO,CAAM,EACf,OAAQmB,GAAQR,EAAQ,eAAeQ,CAAG,CAAC,EAC3C,QAASA,GAASnB,EAAOmB,CAAG,EAAIR,EAAQQ,CAAG,CAAE,EAE5C,CAAC7B,GAAYU,EAAO,WAAW,EACjC,MAAM,IAAI,UACR,0DACF,EAGF,IAAMoB,EAAMpB,EAAO,MACf,IAAIqB,IAAW,QAAQ,IAAI,OAAQ,GAAGA,CAAM,EAC5C,IAAM,CAAC,EAMLC,EAAY,CAACC,EAAcC,IAC/B,WAAW,IAAM,CACf,IAAMC,EAAW,IAAI,MAAMD,CAAG,EAC9BC,EAAI,KAAOF,EACP,MAAM,QAAQf,EAAU,KAAK,GAC/BA,EAAU,MAAM,QAAQ,CAAC,CAACkB,CAAE,IAAMA,EAAGD,CAAG,CAAC,EAEvCnB,EAAG,SACLA,EAAG,QAAQmB,CAAG,CAElB,EAAG,CAAC,EAEAE,EAAc,IAAM,CAIxB,GAHAP,EAAI,OAAO,EACXH,IACAG,EAAI,iBAAkBH,CAAY,EAC9BA,EAAejB,EAAO,WAAY,CACpCsB,EAAU,YAAa,qCAAqC,EAC5D,MACF,CACKN,EAGHA,EAAiBf,GAAwBD,EAAQgB,CAAc,EAF/DA,EAAiBjB,GAAsBC,CAAM,EAI/CoB,EAAI,kBAAmBJ,CAAc,EAEjCE,GACF,WAAWU,EAASZ,CAAc,CAEtC,EAEMY,EAAU,IAAM,CACpBR,EAAI,SAAS,EACb,IAAMb,EAAQD,EACdA,EAAK,IAAUN,EAAO,YAAaa,EAAKC,CAAS,EAEjDC,EAAoB,WAAW,IAAM,CACnCK,EAAI,SAAS,EACbd,EAAG,MAAM,EACTgB,EAAU,YAAa,oBAAoB,CAC7C,EAAGtB,EAAO,iBAAiB,EAE3BoB,EAAI,mBAAmB,EACvB,QAASD,KAAOb,EAGZ,CAAC,mBAAoB,sBAAuB,QAAS,MAAM,EAAE,QAC3Da,CACF,EAAI,GAEJzB,GAAeY,EAAI,KAAMa,CAAG,EAIhCb,EAAG,iBAAiB,OAAQ,IAAM,CAChC,aAAaS,CAAiB,EAC9BK,EAAI,MAAM,EACVJ,EAAiBjB,GAAsBC,CAAM,EAC7CoB,EAAI,kBAAmBJ,CAAc,EACrCC,EAAe,CACjB,CAAC,EAEDX,EAAG,iBAAiB,QAASqB,CAAW,EAExCtB,GAAuBC,EAAIC,EAAOC,CAAS,CAC7C,EAEAY,EAAI,MAAM,EACVQ,EAAQ,EAER,KAAK,MAAQ,CACXL,EAAO,IACPM,EAAS,GACT,CAAE,WAAAC,EAAa,GAAO,UAAAC,EAAY,GAAM,MAAAC,EAAQ,CAAE,EAAI,CAAC,IACpD,CAQH,GAPIA,IACFhB,EAAiBgB,GAEnBd,EAAc,CAACY,EAEfxB,EAAG,MAAMiB,EAAMM,CAAM,EAEjBE,EAAW,CACb,IAAME,EAA6B,CACjC,KAAAV,EACA,OAAAM,EACA,SAAU,EACZ,EAMAF,EAAY,EAER,MAAM,QAAQnB,EAAU,KAAK,GAC/BA,EAAU,MAAM,QAAQ,CAAC,CAACE,EAAUC,CAAO,IAAM,CAC/CD,EAASuB,CAAc,EACvB3B,EAAG,oBAAoB,QAASI,EAAUC,CAAO,CACnD,CAAC,EAGCL,EAAG,UACLA,EAAG,QAAQ2B,CAAc,EACzB3B,EAAG,QAAU,KAEjB,CACF,EAEA,KAAK,KAAQ4B,GAAS,CACpB5B,EAAG,KAAK4B,CAAI,CACd,EAEA,KAAK,iBAAmB,CACtBzB,EACAC,EACAC,IACG,CACC,MAAM,QAAQH,EAAUC,CAAI,CAAC,EAC1BD,EAAUC,CAAI,EAAE,KAAK,CAAC,CAAC0B,CAAC,IAAMA,IAAMzB,CAAQ,GAC/CF,EAAUC,CAAI,EAAE,KAAK,CAACC,EAAUC,CAAO,CAAC,EAG1CH,EAAUC,CAAI,EAAI,CAAC,CAACC,EAAUC,CAAO,CAAC,EAExCL,EAAG,iBAAiBG,EAAMC,EAAUC,CAAO,CAC7C,EAEA,KAAK,oBAAsB,CACzBF,EACAC,EACAC,IACG,CACC,MAAM,QAAQH,EAAUC,CAAI,CAAC,IAC/BD,EAAUC,CAAI,EAAID,EAAUC,CAAI,EAAE,OAAO,CAAC,CAAC0B,CAAC,IAAMA,IAAMzB,CAAQ,GAElEJ,EAAG,oBAAoBG,EAAMC,EAAUC,CAAO,CAChD,CACF,EAEAtB,GAAA,QAASuB,KC5PF,IAAKwB,QACVA,EAAA,WAAa,aACbA,EAAA,YAAc,cACdA,EAAA,KAAO,OAHGA,QAAA,IAKAC,OACVA,EAAA,OAAS,SACTA,EAAA,OAAS,SAFCA,OAAA,IAKAC,OACVA,EAAA,gBAAkB,iBAClBA,EAAA,aAAe,cACfA,EAAA,cAAgB,eAChBA,EAAA,yBAA2B,yBAC3BA,EAAA,YAAc,aACdA,EAAA,cAAgB,eAChBA,EAAA,8BAAgC,4BAChCA,EAAA,cAAgB,eAChBA,EAAA,eAAiB,gBACjBA,EAAA,eAAiB,iBACjBA,EAAA,aAAe,cACfA,EAAA,aAAe,cAZLA,OAAA,IA0DAC,QACVA,EAAA,SAAW,WACXA,EAAA,OAAS,SACTA,EAAA,YAAc,aAHJA,QAAA,IA4NAC,QACVA,EAAA,MAAU,QACVA,EAAA,MAAU,QACVA,EAAA,KAAS,OACTA,EAAA,UAAc,YACdA,EAAA,SAAa,WACbA,EAAA,KAAS,OACTA,EAAA,IAAQ,MACRA,EAAA,QAAY,UACZA,EAAA,cAAkB,gBAClBA,EAAA,QAAY,UACZA,EAAA,SAAa,WACbA,EAAA,SAAa,WAZHA,QAAA,IAeAC,QACVA,EAAA,MAAU,QACVA,EAAA,YAAgB,cAChBA,EAAA,YAAgB,cAChBA,EAAA,UAAc,YACdA,EAAA,0BAA8B,4BAC9BA,EAAA,cAAkB,gBAClBA,EAAA,eAAmB,iBACnBA,EAAA,kBAAsB,oBACtBA,EAAA,iBAAqB,mBACrBA,EAAA,KAAS,OACTA,EAAA,WAAe,aAEfA,EAAA,aAAiB,eACjBA,EAAA,iBAAqB,mBACrBA,EAAA,aAAiB,eACjBA,EAAA,WAAe,aACfA,EAAA,aAAiB,eACjBA,EAAA,QAAY,UACZA,EAAA,aAAiB,eACjBA,EAAA,iBAAqB,mBACrBA,EAAA,iBAAqB,mBACrBA,EAAA,kBAAsB,oBACtBA,EAAA,cAAkB,gBAElBA,EAAA,SAAa,WACbA,EAAA,cAAkB,gBAClBA,EAAA,kBAAsB,oBACtBA,EAAA,cAAkB,gBAClBA,EAAA,cAAkB,gBA7BRA,QAAA,IAgCAC,QACVA,EAAA,SAAa,WACbA,EAAA,cAAkB,gBAClBA,EAAA,kBAAsB,oBACtBA,EAAA,cAAkB,gBAClBA,EAAA,cAAkB,gBALRA,QAAA,IA4IAC,QACVA,EAAA,YAAc,cACdA,EAAA,aAAe,eAFLA,QAAA,IAKAC,QACVA,EAAA,OAAS,SACTA,EAAA,OAAS,SACTA,EAAA,KAAO,OACPA,EAAA,QAAU,UACVA,EAAA,KAAO,OACPA,EAAA,QAAU,UACVA,EAAA,IAAM,MACNA,EAAA,KAAO,OACPA,EAAA,QAAU,UACVA,EAAA,cAAgB,gBAChBA,EAAA,UAAY,YACZA,EAAA,cAAgB,gBAChBA,EAAA,UAAY,YAbFA,QAAA,IAgBAC,QACVA,EAAA,KAAO,OACPA,EAAA,WAAa,aACbA,EAAA,QAAU,UAHAA,QAAA,IAMAC,QACVA,EAAA,MAAQ,QACRA,EAAA,MAAQ,QACRA,EAAA,OAAS,SACTA,EAAA,IAAM,MACNA,EAAA,QAAU,UACVA,EAAA,SAAW,WACXA,EAAA,IAAM,eACNA,EAAA,SAAW,WACXA,EAAA,SAAW,WACXA,EAAA,OAAS,aACTA,EAAA,QAAU,UACVA,EAAA,QAAU,UACVA,EAAA,QAAU,UACVA,EAAA,QAAU,WACVA,EAAA,OAAS,SACTA,EAAA,aAAe,gBACfA,EAAA,KAAO,OACPA,EAAA,OAAS,SACTA,EAAA,KAAO,OACPA,EAAA,KAAO,OACPA,EAAA,WAAa,cArBHA,QAAA,IAwBAC,QACVA,EAAA,QAAU,WACVA,EAAA,UAAY,YACZA,EAAA,gBAAkB,mBAClBA,EAAA,WAAa,cACbA,EAAA,aAAe,eACfA,EAAA,WAAa,cACbA,EAAA,SAAW,WACXA,EAAA,QAAU,UACVA,EAAA,UAAY,aACZA,EAAA,QAAU,UACVA,EAAA,QAAU,WAXAA,QAAA,ICvgBZ,OAAS,MAAMC,GAAQ,YAAYC,OAAoB,OAEhD,IAAMC,EAAmB,IACnBC,GAA2B,IAClCC,GAAmB,IAEZC,EAAoB,CAC9B,WAAyB,6BACzB,KAAmB,qBACtB,EAEaC,GAAiB,CAAIC,EAAUC,IAAkB,CAC5D,GAAID,GAAO,KACT,OAEF,IAAIE,EAAIF,EAAI,QAAQC,CAAU,EAC1BC,IAAM,IAGVF,EAAI,OAAOE,EAAG,CAAC,CACjB,EAEaC,EAAyB,CACpCC,EACA,CACE,SAAAC,EAAW,WACX,gBAAAC,EAAkBX,EAClB,iBAAAY,EAAmB,EACrB,KAMAD,EACEA,EAAkBV,GACdA,GACAU,EAEC,IAAI,QAAQ,CAACE,EAASC,IAAW,CACtC,IAAMC,EAAY,WAAW,IAAM,CAC7BC,IACF,cAAcA,CAAU,EACpBJ,GACFE,EAAO,kDAAkDJ,CAAQ,EAAE,GAGvE,aAAaK,CAAS,CAExB,EAAGJ,CAAe,EAEdK,EAAa,YAAY,SAAY,CACnBP,EAAS,CAAE,QAAAI,EAAS,OAAAC,EAAQ,WAAAE,CAAW,CAAC,IAE1D,cAAcA,CAAU,EACxB,aAAaD,CAAS,EAG1B,EAAGb,EAAgB,CACrB,CAAC,GAGUe,GAAgBC,GAC3B,IAAI,QAASL,GAAY,CACvB,IAAMM,EAAS,IAAI,WACnBA,EAAO,cAAcD,CAAI,EACzBC,EAAO,OAAS,UAAY,CAC1BN,EAAQM,EAAO,MAAM,CACvB,CACF,CAAC,EAGUC,EAAU,IAAMtB,GAAO,EAEvBuB,GAAeC,GAAiBvB,GAAauB,CAAI,EAwEvD,IAAMC,GAAmB,CAAC,CAC/B,IAAAC,EACA,KAAAC,EACA,QAAAC,EAAU,GACV,mBAAAC,EAAqB,EACvB,IAMuBH,EAAI,MAAM,OAAO,EAAE,IAAKA,GAAQA,EAAI,QAAQ,MAAO,EAAE,CAAC,EAEhD,OAAO,CAACI,EAAKC,IAAS,CAC/C,IAAMC,EAAaJ,EAAU,EAAI,OAC3BK,EAAeH,IAAMC,CAAI,EAE/B,GAAI,CAACE,EACH,OAAOD,EAET,GAAI,MAAM,QAAQC,CAAY,GAAK,QAAQ,KAAKF,CAAI,EAAG,CACrD,IAAMG,EAAQ,SAASH,EAAM,EAAE,EAC/B,OAAIG,GAAS,GAAKA,EAAQD,EAAa,OAC7BH,EAAIC,CAAI,EAAIE,EAAaC,CAAK,EAE/BJ,EAAIC,CAAI,GAAKC,CAExB,KACE,QAAOF,EAAIC,CAAI,GAAKC,CAExB,EAAGL,GAAQ,CAAC,CAAC,GAKG,CAAC,EAGNQ,GAAQ,CAACC,EAAcC,EAAe,MAC1C,IAAI,QAASC,GAAY,WAAWA,EAASF,EAAOC,CAAY,CAAC,EA0CnE,IAAME,GAAiB,CAACC,EAAkBC,IACxCD,EAAU,OAAQE,GAAQA,EAAI,MAAQD,EAAS,GAAG,EAiBpD,IAAME,EAAkB,CAAC,CAC9B,IAAAC,EACA,MAAAC,CACF,IAIQA,GAASA,IAAU,GAAKA,IAAU,GAC/B,CAAE,CAACD,CAAG,EAAGC,CAAM,EAEf,CAAC,EAICC,GAAkB,CAACC,EAAaC,IACpC,KAAK,MAAM,KAAK,OAAO,GAAKA,EAAMD,EAAM,EAAE,EAAIA,EAE1CE,EAAgB,IACpBH,GAAgB,EAAG,OAAO,gBAAgB,EC5Q5C,IAAMI,EAAa,MACxBC,EACAC,EAII,CAAC,IACF,CACH,GAAM,CAAE,eAAAC,EAAiB,EAAG,SAAAC,CAAS,EAAIF,EACrCG,EAAaH,EAAQ,YAAc,EACvC,KAAOG,GACL,GAAI,CAEF,OADe,MAAMJ,EAAQ,CAE/B,OAASK,EAAY,CAGnB,GAFAF,IAAW,EACXC,IACIA,EAAa,EACf,MAAME,GAAMJ,CAAc,EAC1B,MAAMH,EAAWC,EAAS,CAAE,GAAGC,EAAS,WAAAG,CAAW,CAAC,MAEpD,OAAMC,CAEV,CAEJ,EC2BO,IAAME,EAAN,KAAkB,CAiBvB,YAAY,CACV,OAAAC,EACA,IAAAC,EAAMC,EAAkB,WACxB,gBAAAC,EAAkB,GAClB,iBAAAC,EAAmB,EACnB,gBAAAC,EAAkBC,CACpB,EAAoB,CArBpB,gBAA6B,CAAC,EAI9B,qBAAuC,CAAC,EACxC,mBAA0B,CAAC,EAQ3B,0BAAsC,KA2BtC,KAAU,sBAAwB,IAAM,KAAK,KAAK,aAAe,EAyBjE,KAAU,gBAAkB,IACnB,KAAK,kBAAkB,OAAO,OAAS,gBAoGhD,KAAU,KAAQC,GAAgB,CAChC,KAAK,IAAI,KAAK,KAAK,UAAU,CAACA,CAAG,CAAC,CAAC,CACrC,EAMA,KAAQ,YAAc,MACpBC,GACoC,CACpC,GAAI,CACF,OAAO,MAAMC,EAAW,SAAY,CAClC,IAAMC,EAAWC,EAAQ,EAEzB,GAAI,OAAOH,GAAS,UAAYI,GAAYJ,CAAI,EAC9C,MAAO,CACL,SAAUA,EACV,UAAWA,EACX,SAAAE,EACA,sBACF,EAGF,IAAMG,EACJ,OAAOL,GAAS,SAAWA,EAAO,MAAMM,GAAaN,CAAI,EAE3D,MAAO,CACL,SAAUK,EACV,UAAWA,EACX,SAAAH,EACA,sBACF,CACF,CAAC,CACH,OAAS,EAAG,CACV,MAAM,CACR,CACF,EAqTA,0BAAuB,MAAO,CAC5B,WAAAK,EACA,iBAAAC,EACA,OAAAC,EACA,MAAAC,EACA,WAAAC,EACA,aAAAC,EACA,mBAAAC,EACA,kBAAAC,EACA,4BAAAC,EACA,YAAAC,EACA,cAAAC,EACA,eAAAC,EACA,MAAAC,CACF,IAA+D,CAC7D,IAAMC,EAAaD,GAAS,KAAK,kBAC7BE,EAEJ,GAAI,CACF,OAAO,MAAMpB,EACX,SAAY,CACV,MAAM,KAAK,iBAAiB,EAC5B,IAAMqB,EAAQ,MAAM,KAAK,YAAYf,CAAU,EAC/C,GAAI,CAACe,GAAO,UAAW,OAAO,KAE9B,IAAMpB,EAAWgB,GAAkBf,EAAQ,EAC3C,KAAK,KAAK,CACR,WAAYmB,EAAM,UAClB,qCACA,SAAApB,EACA,iBAAAM,EACA,GAAGe,EAAgB,CAAE,IAAK,SAAU,MAAOd,CAAO,CAAC,EACnD,GAAGc,EAAgB,CAAE,IAAK,QAAS,MAAOb,CAAM,CAAC,EACjD,GAAGa,EAAgB,CAAE,IAAK,aAAc,MAAOZ,CAAW,CAAC,EAC3D,GAAGY,EAAgB,CAAE,IAAK,eAAgB,MAAOX,CAAa,CAAC,EAC/D,GAAGW,EAAgB,CAAE,IAAK,cAAe,MAAOP,CAAY,CAAC,EAC7D,GAAGO,EAAgB,CACjB,IAAK,qBACL,MAAOV,CACT,CAAC,EACD,GAAGU,EAAgB,CACjB,IAAK,oBACL,MAAOT,CACT,CAAC,EACD,GAAGS,EAAgB,CACjB,IAAK,8BACL,MAAOR,CACT,CAAC,EACD,GAAIE,EAAgB,CAAE,cAAAA,CAAc,EAAI,CAAC,CAC3C,CAAC,EACDI,EAAM,KAAK,eAAe,CACxB,SAAAnB,CACF,CAAC,EAED,IAAMsB,EAAc,MAAMC,EACxB,CAAC,CAAE,QAAAC,EAAS,OAAAC,CAAO,IAAM,CACvB,IAAMC,EAAgB,KAAK,iBAAiB,CAC1C,SAAA1B,CACF,CAAC,EAED,GAAK0B,EAEL,IAAIA,GAAe,MACjB,OAAAD,EAAOC,CAAa,EACb,GAGT,GAAIA,EAEF,OAAAF,EAAQE,CAAa,EACd,GAEX,EACA,CACE,SAAU,oBACV,gBAAiB,KAAK,gBACxB,CACF,EAEA,OAAAP,EAAI,QAAQ,EAELG,CACT,EACA,CACE,WAAYJ,EACZ,SAAU,IAAM,CACdC,GAAK,QAAQ,CACf,CACF,CACF,CACF,OAASQ,EAAQ,CACf,MAAMA,CACR,CACF,EAEA,wBAAqB,MAAO,CAC1B,WAAAtB,EACA,YAAAS,EACA,eAAAE,EACA,MAAAC,CACF,IAAkD,CAChD,IAAMC,EAAaD,GAAS,KAAK,kBAC7BE,EAEJ,GAAI,CACF,OAAO,MAAMpB,EACX,SAAY,CACV,MAAM,KAAK,iBAAiB,EAC5B,IAAM6B,EAAgBvB,EAClB,MAAM,KAAK,YAAYA,CAA2B,EAClD,KAEEL,EAAWgB,GAAkBf,EAAQ,EAC3C,KAAK,KAAK,CACR,SAAAD,EACA,wBACA,WAAY4B,GAAe,UAC3B,GAAGP,EAAgB,CAAE,IAAK,cAAe,MAAOP,CAAY,CAAC,CAC/D,CAAC,EAEDK,EAAM,KAAK,eAAe,CACxB,SAAAnB,CACF,CAAC,EAED,IAAM6B,EAAW,MAAMN,EACrB,CAAC,CAAE,QAAAC,EAAS,OAAAC,CAAO,IAAM,CACvB,IAAMK,EAAiB,KAAK,iBAAiB,CAC3C,SAAA9B,CACF,CAAC,EAED,GAAK8B,EAEL,IAAIA,GAAgB,MAClB,OAAAL,EAAOK,CAAc,EACd,GAGT,GAAIA,EACF,cAAO,KAAK,gBAAgB9B,CAAQ,EACpCwB,EAAQM,CAAc,EACf,GAEX,EACA,CACE,SAAU,0BACV,gBAAiB,KAAK,gBACxB,CACF,EAEA,OAAAX,EAAI,QAAQ,EAELU,CACT,EACA,CACE,WAAYX,EACZ,SAAU,IAAM,CACdC,GAAK,QAAQ,CACf,CACF,CACF,CACF,OAASQ,EAAG,CACV,MAAMA,CACR,CACF,EAEA,2BAAwB,MACtBI,GAEO,KAAK,kBAAkB,CAC5B,QAAS,CACP,GAAGA,EACH,iCACF,EACA,SAAU,yBACZ,CAAC,EA0FH,gBAAa,MAAO,CAClB,WAAA1B,EACA,cAAA2B,EACA,WAAAvB,EACA,aAAAC,EACA,YAAAI,EACA,cAAAC,EACA,eAAAC,EACA,MAAAC,CACF,IAAoC,CAClC,IAAMC,EAAaD,GAAS,KAAK,kBAC7BE,EAEJ,GAAI,CACF,OAAO,MAAMpB,EACX,SAAY,CACV,MAAM,KAAK,iBAAiB,EAC5B,IAAI6B,EAEJA,EAAgB,MAAM,KAAK,YAAYvB,CAA2B,EAElE,IAAML,EAAWgB,GAAkBf,EAAQ,EAE3C,KAAK,KAAK,CACR,SAAAD,EACA,WAAY4B,GAAe,UAC3B,wBACA,cAAAI,EACA,GAAGX,EAAgB,CAAE,IAAK,cAAe,MAAOP,CAAY,CAAC,EAC7D,GAAIL,EAAa,CAAE,WAAAA,CAAW,EAAI,CAAC,EACnC,GAAIM,EAAgB,CAAE,cAAAA,CAAc,EAAI,CAAC,EACzC,GAAIL,EAAe,CAAE,aAAAA,CAAa,EAAI,CAAC,CACzC,CAAC,EAEDS,EAAM,KAAK,eAAe,CACxB,SAAAnB,CACF,CAAC,EAED,IAAM6B,EAAW,MAAMN,EACrB,CAAC,CAAE,QAAAC,EAAS,OAAAC,CAAO,IAAM,CACvB,IAAMQ,EAAgB,KAAK,iBAAiB,CAAE,SAAAjC,CAAS,CAAC,EACxD,GAAKiC,EAEL,IAAIA,GAAe,MACjB,OAAAR,EAAOQ,CAAa,EACb,GAGT,GAAIA,EACF,cAAO,KAAK,gBAAgBjC,CAAQ,EACpCwB,EAAQS,CAAa,EACd,GAEX,EACA,CAAE,SAAU,cAAe,gBAAiB,KAAK,gBAAiB,CACpE,EAEA,OAAAd,EAAI,QAAQ,EAELU,CACT,EACA,CACE,WAAYX,EACZ,SAAU,IAAM,CACdC,GAAK,QAAQ,CACf,CACF,CACF,CACF,OAASQ,EAAG,CACV,MAAMA,CACR,CACF,EAEA,mBAAgB,MAAO,CACrB,OAAAO,EACA,gBAAAC,EAAkB,IAClB,eAAAC,EAAiB,EACjB,YAAAtB,EACA,eAAAE,EACA,MAAAC,CACF,IAAmD,CACjD,IAAMC,EAAaD,GAAS,KAAK,kBAC7BE,EAEJ,GAAI,CACF,OAAO,MAAMpB,EACX,SAAY,CACV,MAAM,KAAK,iBAAiB,EAC5B,IAAMC,EAAWgB,GAAkBf,EAAQ,EAE3C,KAAK,KAAK,CACR,OAAAiC,EACA,SAAAlC,EACA,gBAAAmC,EACA,eAAAC,EACA,GAAGf,EAAgB,CAAE,IAAK,cAAe,MAAOP,CAAY,CAAC,EAC7D,wBACF,CAAC,EAEDK,EAAM,KAAK,eAAe,CACxB,SAAAnB,CACF,CAAC,EAED,IAAM6B,EAAW,MAAMN,EACrB,CAAC,CAAE,QAAAC,EAAS,OAAAC,CAAO,IAAM,CACvB,IAAMY,EACJ,KAAK,gBAAgBrC,CAAQ,EAE/B,GAAKqC,GAAuB,MAC1B,OAAAZ,EAAOY,CAAoB,EACpB,GAGT,GAAIA,GAAe,QAAUD,EAC3B,cAAO,KAAK,gBAAgBpC,CAAQ,EACpCwB,EAAQa,CAAa,EACd,EAEX,EACA,CACE,SAAU,iBACV,gBAAiB,KAAK,gBACxB,CACF,EAEA,OAAAlB,EAAI,QAAQ,EACLU,CACT,EACA,CACE,WAAYX,EACZ,SAAU,IAAM,CACdC,GAAK,QAAQ,CACf,CACF,CACF,CACF,OAASQ,EAAG,CACV,MAAMA,CACR,CACF,EAEA,iBAAc,MAAOI,GAAuB,CAE1C,GAAM,CAAE,eAAAO,EAAgB,MAAArB,EAAO,eAAAD,EAAgB,GAAGuB,CAAgB,EAChER,EAEIb,EAAaD,GAAS,KAAK,kBAC7BE,EAEJ,GAAI,CACF,OAAO,MAAMpB,EACX,SAAY,CACV,MAAM,KAAK,iBAAiB,EAC5B,IAAMC,EAAWgB,GAAkBf,EAAQ,EAE3C,KAAK,KAAK,CACR,GAAGsC,EACH,SAAAvC,EACA,sBACF,CAAC,EAED,IAAIwC,EACAC,EAEJ,OAAAtB,EAAM,KAAK,eAAe,CACxB,SAAAnB,EACA,eAAgB,CAAC6B,EAAUa,IAAU,CACnCJ,IAAiBT,EAAUa,CAAK,EAC5Bb,GAAU,SAAW,QACvBW,EAASX,EACAa,IACTD,EAAcC,EAElB,CACF,CAAC,EAE2B,MAAMnB,EAChC,CAAC,CAAE,QAAAC,EAAS,OAAAC,CAAO,IAAM,CACvB,GAAIe,EACF,OAAAhB,EAAQgB,CAAM,EACP,GACF,GAAIC,EACT,OAAAhB,EAAOgB,CAAW,EACX,EAEX,EACA,CACE,iBAAkB,GAClB,gBAAiB,GAAK,GAAK,GAC7B,CACF,CAGF,EACA,CACE,WAAYvB,EACZ,SAAU,IAAM,CACdC,GAAK,QAAQ,CACf,CACF,CACF,CACF,OAASQ,EAAG,CACV,MAAMA,CACR,CACF,EAEA,gBAAa,MACXI,EACAY,IAC+C,CAE/C,GAAM,CACJ,gBAAAC,EACA,MAAA3B,EACA,eAAAD,EACA,cAAA6B,EACA,GAAGC,CACL,EAAIf,EAEEb,EAAaD,GAAS,KAAK,kBAC7BE,EACA4B,EAAsB,CAAC,EACvBC,EAAa,EAEjB,GAAI,CACF,OAAO,MAAMjD,EACX,SAAY,CACV,MAAM,KAAK,iBAAiB,EAC5BiD,IACA,IAAMC,EAAwB,KAAK,cAAc,OAAQC,GACvDH,EAAU,SAASG,EAAI,QAAQ,CACjC,EAEMlD,EAAWgB,GAAkBf,EAAQ,EAC3C8C,EAAU,KAAK/C,CAAQ,EAEvB,IAAMmD,EAAiBN,EAAgBI,EAAsB,OAE7D,KAAK,KAAK,CACR,GAAGH,EACH,GAAIA,EAAkB,KAClB,CAAE,KAAMA,EAAkB,IAAK,EAC/B,CAAE,KAAMM,EAAc,CAAE,EAC5B,GAAIT,GAAe,CAAC,EACpB,cAAeQ,EACf,SAAAnD,EACA,qBACF,CAAC,EAEDmB,EAAM,KAAK,eAAe,CACxB,gBAAAyB,EACA,SAAU5C,EACV,0BACA,eAAgB8C,EAAkB,cAEpC,CAAC,EAED,IAAMO,EAAU,MAAM,KAAK,iBAAiB,CAC1C,SAAUN,EACV,cAAAF,EACA,IAAA1B,CACF,CAAC,EAED,OAAAA,EAAI,QAAQ,EAELkC,CACT,EACA,CACE,WAAYnC,EACZ,SAAU,IAAM,CACdC,GAAK,QAAQ,CACf,CACF,CACF,CACF,OAASQ,EAAG,CACV,GAAKA,EAAU,SACb,MAAMA,EAER,GAAIqB,GAAc9B,EAChB,OAAO,KAAK,uBAAuB,CACjC,UAAA6B,EACA,MAAOpB,CACT,CAAC,CAEL,CACF,EAEA,iBAAc,MACZI,GAEO,KAAK,kBAAkB,CAC5B,QAAS,CACP,GAAGA,EACH,sBACF,EACA,SAAU,cACZ,CAAC,EAGH,kBAAe,MACbA,GAEO,KAAK,kBAAkB,CAC5B,QAAS,CACP,GAAGA,EACH,uBACF,EACA,SAAU,eACZ,CAAC,EAGH,KAAU,kBAAoB,MAAU,CACtC,QAAAA,EACA,SAAAuB,CACF,IAGkB,CAChB,GAAM,CAAE,MAAArC,EAAO,eAAAD,EAAgB,GAAGuC,CAAY,EAAIxB,EAE5Cb,EAAaD,GAAS,KAAK,kBAC7BE,EAEJ,GAAI,CACF,OAAO,MAAMpB,EACX,SAAY,CACV,MAAM,KAAK,iBAAiB,EAC5B,IAAMC,EAAWgB,GAAkBf,EAAQ,EAE3C,KAAK,KAAK,CACR,GAAGsD,EACH,SAAAvD,CACF,CAAC,EAEDmB,EAAM,KAAK,eAAe,CACxB,SAAAnB,CACF,CAAC,EAED,IAAM6B,EAAW,MAAMN,EACrB,CAAC,CAAE,QAAAC,EAAS,OAAAC,CAAO,IAAM,CACvB,IAAMI,EAAW,KAAK,iBAAiB,CAAE,SAAA7B,CAAS,CAAC,EACnD,GAAK6B,EAEL,IAAIA,GAAU,MACZ,OAAAJ,EAAOI,CAAQ,EACR,GAGT,GAAIA,EACF,cAAO,KAAK,gBAAgB7B,CAAQ,EACpCwB,EAAQK,CAAQ,EACT,GAEX,EACA,CACE,SAAAyB,EACA,gBAAiB,KAAK,gBACxB,CACF,EAEA,OAAAnC,EAAI,QAAQ,EACLU,CACT,EACA,CACE,WAAYX,EACZ,SAAU,IAAM,CACdC,GAAK,QAAQ,CACf,CACF,CACF,CACF,OAASQ,EAAG,CACV,MAAMA,CACR,CACF,EAgJA,KAAQ,iBAAmB,CAAC,CAAE,SAAA3B,CAAS,IAA4B,CACjE,IAAMwD,EAAQ,KAAK,gBAAgBxD,CAAQ,IAAI,CAAC,EAC1CyD,EAAa,KAAK,gBAAgBzD,CAAQ,EAChD,MAAI,CAACwD,GAAS,CAACC,EAAmB,KAC3BA,GAAY,MAAQA,EAAaD,CAC1C,EAsBA,gBAAa,SAAY,CACvB,KAAK,iBAAmB,GACxB,KAAK,KAAK,YAAY,EACtB,KAAK,KAAK,QAAQ,CACpB,EAEA,KAAQ,UAAY,IAClB,KAAK,sBAAsB,GAAK,CAAC,CAAC,KAAK,uBAxxCvC,KAAK,QAAUlE,EACf,KAAK,KAAOC,EACZ,KAAK,SAAW,SAChB,KAAK,iBAAmBE,EACxB,KAAK,kBAAoBC,EACzB,KAAK,iBAAmBC,CAC1B,CAEA,aAAa,WAAW+D,EAAwB,CAC9C,GAAI,CACF,IAAMC,EAAW,IAAI,KAAKD,CAAK,EAC/B,aAAMC,EAAS,iBAAiB,EACzBA,CACT,OAAS,EAAG,CACV,MAAM,CACR,CACF,CA+BU,YAAY,CACpB,IAAAxC,EAEA,SAAAyC,EACA,SAAA5D,CACF,EAKG,CACD,IAAM6D,EAAYhE,GAIZ,CACJ,IAAMiE,EAAe,MAAM,QAAQjE,GAAK,IAAI,EAAIA,EAAI,KAAO,CAACA,EAAI,IAAI,EAE9DkE,EAAelE,IAAc,CAAC,GAAG,OAClCA,IAAc,CAAC,GAAG,OACnB,MAAM,QAAQA,GAAK,MAAM,EACzBA,EAAI,OACJ,CAACA,EAAI,MAAM,EAETmE,EAAkBF,EAAa,OAClCG,IAAOA,GAAG,UAAYA,GAAG,YAAcjE,CAC1C,EAMA,GAJuB+D,EAAY,OAChCE,IAAYA,GAAG,UAAYA,GAAG,YAAcjE,CAC/C,EAEmB,OAAQ,CACzBmB,EAAI,CAAE,MAAO,CAAE,GAAI4C,EAAY,CAAC,GAAK,CAAC,CAAG,CAAE,CAAC,EAC5C,MACF,CAEA,GAAIC,EAAgB,OAAQ,CAC1B7C,EAAI,CAAE,CAACnB,CAAQ,EAAG8D,CAAa,CAAC,EAChC,MACF,CACF,EACMI,EAAgB,CAAE,IAAKlE,GAAYC,EAAQ,EAAG,SAAA4D,EAAU,SAAAD,CAAS,EACvE,YAAK,WAAW,KAAKM,CAAa,EAK3B,CACL,QALc,IAAM,CACpB,KAAK,WAAaC,GAAe,KAAK,WAAYD,CAAa,CACjE,CAIA,CACF,CAEU,SAAU,CAClB,KAAK,IAAI,OAAUvC,GAAW,CACxB,KAAK,uBACP,KAAK,KAAK,CACR,0BACA,OAAQ,KAAK,QACb,sBAAuB,KAAK,sBAC9B,CAAC,EAED,KAAK,KAAK,CAAE,OAAQ,KAAK,QAAS,yBAAmC,CAAC,EAGxE,KAAK,YAAY,CACf,0BACA,IAAMyC,GAAM,CACV,GAAIA,GAAG,MAAO,CACZ,KAAK,iBAAmBA,EACxB,MACF,CACA,KAAK,uBACHA,GAAI,iBAA4B,CAAC,GAAG,sBACtC,KAAK,iBAAmB,MAC1B,CACF,CAAC,CACH,EAEA,KAAK,IAAI,UAAazC,GAAW,CAC/B,IAAM0C,EAAO,KAAK,MAAM1C,EAAE,IAAI,EAC9B,QAAWR,KAAO,KAAK,WAErB,GADgBA,GAAa,WAAWkD,CAAI,EAChC,MAEhB,EAEA,KAAK,IAAI,QAAW1C,GAAW,CAGzB,KAAK,gBAAgB,CAG3B,CACF,CAOQ,QAAQR,EAAU,CACxBmD,GAAe,KAAK,WAAYnD,CAAG,CACrC,CAiCQ,eAAe,CACrB,gBAAAyB,EACA,SAAA5C,EACA,SAAA4D,EACA,eAAAW,EACA,eAAAC,CACF,EAMG,CACD,OAAO,KAAK,YAAY,CACtB,SAAUxE,EACV,IAAMoE,GAAM,CACV,IAAIK,EAAUL,IAAIpE,CAAQ,GAAgB,OACvCkD,GAAQA,EAAI,WAAalD,CAC5B,EAEIoE,EAAE,OACJxB,IAAkB6B,EAAQL,GAAG,OAASA,CAAC,EACvC,KAAK,aAAeA,IAEpBK,EAASA,EAAO,IAAKrD,IAAW,CAC9B,GAAGA,EACH,eAAAmD,EACA,eAAAC,CACF,EAAE,EACF5B,IAAkB6B,EAAQL,GAAG,OAASA,CAAC,EAEnC,KAAK,WAAa,SAEpB,KAAK,cAAgB,CACnB,GAAG,KAAK,cACR,IAAIA,IAAIpE,CAAQ,GAAK,CAAC,GAAG,IAAKoB,IAAmB,CAC/C,GAAGA,EACH,eAAAmD,EACA,eAAAC,CACF,EAAE,CACJ,EAEA,KAAK,cAAgB,CAAC,GAAG,KAAK,cAAe,GAAGC,CAAM,EAG5D,EACA,SAAAb,CACF,CAAC,CACH,CAEQ,eAAe,CACrB,eAAAtB,EACA,SAAAtC,CACF,EAMG,CACD,OAAO,KAAK,YAAY,CACtB,SAAUA,EACV,IAAMoE,GAAM,CACV,IAAM1B,EAAQ0B,GAAG,MAEX5B,EAAS4B,IAAIpE,CAAQ,IAAI,CAAC,EAC5B6B,EAAWW,GAAQ,WAAaxC,EAAWwC,EAAS,MAEpDX,GAAYa,IACdJ,IAAiBT,GAAY,OAAWa,CAAK,CAEjD,CACF,CAAC,CACH,CAEQ,eAAe,CAAE,SAAA1C,CAAS,EAAyB,CACzD,OAAO,KAAK,YAAY,CAUtB,SAAUA,EACV,IAAMoE,GAAM,CACV,GAAIA,EAAE,MAAO,CACX,KAAK,gBAAgBpE,CAAQ,EAAIoE,EACjC,MACF,CAEA,IAAMZ,EAAQkB,GAAiB,CAC7B,IAAK1E,EACL,KAAMoE,EACN,QAAS,EACX,CAAC,EAEG,MAAM,QAAQZ,CAAK,EACrBA,EAAM,QAASS,GAAM,CACnB,KAAK,gBAAgBA,EAAE,QAAQ,EAAI,CACjC,GAAI,KAAK,gBAAgBA,EAAE,QAAQ,GAAK,CAAC,EACzCA,CACF,CACF,CAAC,EAED,KAAK,gBAAgBT,EAAM,QAAQ,EAAIA,CAE3C,CACF,CAAC,CACH,CAEA,MAAM,cACJ,CACE,WAAA/C,EACA,aAAAC,EACA,eAAAiE,EACA,UAAAC,EACA,eAAAL,EACA,eAAAC,EACA,UAAAK,EACA,UAAAC,EACA,SAAAC,EACA,OAAAxE,EACA,MAAAC,EACA,MAAAwE,EACA,MAAAC,EACA,UAAAC,EACA,KAAAC,EACA,SAAAC,EACA,SAAAC,EACA,mBAAAC,EACA,gBAAAC,EACA,cAAA1C,EAAgB,EAChB,gBAAAD,EACA,YAAA9B,GACA,eAAAE,GACA,MAAAC,GACA,QAAAuE,EACA,WAAAC,GACA,cAAA1E,EACA,WAAA2E,EACA,KAAAC,EACA,WAAAC,EACA,WAAAC,EACA,SAAAC,CACF,EAGAnD,GACqC,CACrC,IAAIxB,EACA4E,EACAhD,EAAsB,CAAC,EACvBC,EAAa,EAEX9B,GAAaD,IAAS,KAAK,kBAEjC,GAAI,CACF,MAAM,KAAK,iBAAiB,EAE5B,IAAI+E,EAA+B,KAC/BC,EAA+B,KAC/BC,EAAwC,CAAC,EAE7C,GAAIrB,EAAW,CACb,IAAMnD,EAAgB,MAAM,KAAK,YAAYmD,CAAS,EAEtD,GAAI,CAACnD,EAAe,MAAO,CAAC,EAC5BsE,EAAgBtE,EAAc,SAChC,CACA,GAAIoD,EAAW,CACb,IAAMqB,EAAwB,MAAM,KAAK,YAAYrB,CAAS,EAC9D,GAAI,CAACqB,EAAuB,MAAO,CAAC,EACpCF,EAAgBE,EAAsB,SACxC,CAEA,GAAIT,GAAY,OACd,QAASU,EAAI,EAAGA,EAAIV,EAAW,OAAQU,IAAK,CAC1C,IAAMC,EAA2BX,EAAWU,CAAC,EACvC,CACJ,QAAAE,EACA,UAAAC,EACA,OAAAC,EACA,WAAAlF,EACA,YAAAmF,GACA,oBAAAC,GACA,kBAAAC,GACA,MAAOC,EACT,EAAIP,EAEEzE,GAAgBN,EAClB,MAAM,KAAK,YAAYA,CAA2B,EAClD,KAEJ4E,EAAe,KAAK,CAClB,WAAYtE,IAAe,UAC3B,MAAOgF,GACP,QAAAN,EACA,UAAAC,EACA,OAAAC,EACA,GAAGnF,EAAgB,CACjB,IAAK,sBACL,MAAOqF,EACT,CAAC,EACD,GAAGrF,EAAgB,CACjB,IAAK,oBACL,MAAOsF,EACT,CAAC,EACD,YAAaF,IAAe,YAC9B,CAAC,CACH,CAGF,OAAAV,EAAgB,CACd,0BACA,MAAAf,EACA,eAAgBT,EAChB,GAAIC,EAAiB,CAAE,eAAAA,CAAe,EAAI,CAAC,EAC3C,GAAIjE,EAAS,CAAE,OAAAA,CAAO,EAAI,CAAC,EAC3B,GAAIC,EAAQ,CAAE,MAAAA,CAAM,EAAI,CAAC,EACzB,cAAAqC,EAEA,GAAIpC,EAAa,CAAE,WAAAA,CAAW,EAAI,CAAC,EACnC,GAAIC,EAAe,CAAE,aAAAA,CAAa,EAAI,CAAC,EACvC,GAAIiE,EAAiB,CAAE,eAAAA,CAAe,EAAI,CAAC,EAC3C,GAAGtD,EAAgB,CAAE,IAAK,YAAa,MAAOuD,CAAU,CAAC,EACzD,GAAGvD,EAAgB,CAAE,IAAK,WAAY,MAAO0D,CAAS,CAAC,EACvD,GAAG1D,EAAgB,CAAE,IAAK,WAAY,MAAO+D,CAAS,CAAC,EACvD,GAAG/D,EAAgB,CAAE,IAAK,WAAY,MAAOgE,CAAS,CAAC,EACvD,GAAGhE,EAAgB,CAAE,IAAK,aAAc,MAAOoE,EAAW,CAAC,EAC3D,GAAGpE,EAAgB,CACjB,IAAK,qBACL,MAAOiE,CACT,CAAC,EACD,GAAGjE,EAAgB,CAAE,IAAK,QAAS,MAAO4D,CAAM,CAAC,EACjD,GAAIM,EAAkB,CAAE,gBAAAA,CAAgB,EAAI,CAAC,EAC7C,GAAIJ,EAAO,CAAE,KAAMA,CAAK,EAAI,CAAE,KAAM/B,EAAc,CAAE,EACpD,GAAI8B,EAAY,CAAE,UAAAA,CAAU,EAAI,CAAC,EACjC,GAAIM,EAAU,CAAE,QAAAA,CAAQ,EAAI,CAAC,EAC7B,GAAIM,EAAW,CAAE,SAAAA,CAAS,EAAI,CAAC,EAC/B,GAAGzE,EAAgB,CAAE,IAAK,cAAe,MAAOP,EAAY,CAAC,EAC7D,GAAIkF,EAAgB,CAAE,UAAWA,CAAc,EAAI,CAAC,EACpD,GAAIC,EAAgB,CAAE,UAAWA,CAAc,EAAI,CAAC,EACpD,GAAIlF,EAAgB,CAAE,cAAAA,CAAc,EAAI,CAAC,EACzC,GAAImF,EAAe,OAAS,CAAE,WAAYA,CAAe,EAAI,CAAC,EAC9D,GAAIP,GAAM,OAAS,CAAE,KAAMA,CAAK,EAAI,CAAC,EACrC,GAAIC,GAAY,OAAS,CAAE,WAAAA,CAAW,EAAI,CAAC,EAC3C,GAAIC,GAAY,OAAS,CAAE,WAAAA,CAAW,EAAI,CAAC,EAC3C,GAAIlD,IAAe,CAAC,CACtB,EAEO,MAAM5C,EACX,SAAY,CACViD,IACA7B,GAAK,QAAQ,EACb,IAAM8B,EAAwB,KAAK,cAAc,OAAQC,GACvDH,EAAU,SAASG,EAAI,QAAQ,CACjC,EAEMlD,EAAWgB,IAAkBf,EAAQ,EAE3C8C,EAAU,KAAK/C,CAAQ,EAEvB,IAAMmD,EAAiBN,EAAgBI,EAAsB,OAEvD4D,EAAmB,CACvB,GAAGd,EACH,SAAU/F,EACV,cAAemD,CACjB,EACA,KAAK,KAAK0D,CAAgB,EAE1B1F,EAAM,KAAK,eAAe,CACxB,gBAAAyB,EACA,SAAU5C,EACV,0BACA,eAAAuE,EACA,eAAAC,CACF,CAAC,EAED,IAAMnB,EAAU,MAAM,KAAK,iBAAiB,CAC1C,SAAUN,EACV,cAAAF,EACA,IAAA1B,CACF,CAAC,EAED,OAAAA,EAAI,QAAQ,EAELkC,CACT,EACA,CACE,WAAYnC,GACZ,SAAU,IAAM,CACdC,GAAK,QAAQ,CACf,CACF,CACF,CACF,OAASQ,EAAG,CACV,GAAIqB,GAAc9B,GAChB,OAAO,KAAK,uBAAuB,CAAE,UAAA6B,EAAW,MAAOpB,CAAE,CAAC,EAE5D,MAAMA,CACR,CACF,CAgoBA,MAAM,kBAAmB,CAEvB,GADkB,KAAK,UAAU,GACd,KAAK,OAASnC,EAAkB,KAAM,OAEzD,IAAMsH,EAAgB,IAChBC,EAAkB,IAGxB,GAAI,CACF,GAAI,KAAK,gBAAgB,EACvB,MAAM,KAAK,iBAGb,OAAO,IAAI,QAAQ,CAACvF,EAASC,IAAW,CAEtC,IAAIR,EAAQ,EACN+F,EAAY,GAEZC,EAAsBhH,EAAQ,EAEhCiH,EACAC,EAEEC,EAAoB,IAAM,CAC9B,KAAK,qBAAuB,KAC5B,cAAcF,CAAe,EAC7B,cAAcC,CAAiB,CACjC,EAEI,KAAK,WAAa,WACpBD,EAAkB,YAAY,SAAY,CACxC,GAAI,CACF,IAAMG,EAAe,KAAK,UAAU,EAGhCC,EAAmB,IAGrB,CAAC,KAAK,sBACNL,IAAwB,KAAK,wBAExB,KAAK,uBACR,KAAK,qBAAuBA,GAE9BK,EAAmB,IAKrB,IAAMC,EAAetG,EAAQ,KAAO,GAAKqG,EAErCD,GACFD,EAAkB,EAClB5F,EAAQ,EAAI,GACHP,GAAS+F,GAClBI,EAAkB,EAClB3F,EAAO,IAAI,MAAM,iBAAiB,CAAC,IAE/B8F,GACF,KAAK,QAAQ,EAEftG,IAEJ,OAASyB,EAAO,CACd0E,EAAkB,EAClB3F,EAAOiB,CAAK,CACd,CACF,EAAGoE,CAAa,GAGlBK,EAAoB,YAAY,SAAY,CAG1C,GAFqB,KAAK,UAAU,EAElB,CAChBC,EAAkB,EAClB5F,EAAQ,EAAI,EACZ,MACF,CACA,GAAM,KAAK,gBAAgB,EAAG,CAC5B4F,EAAkB,EAClB3F,EAAO,KAAK,gBAAgB,EAC5B,MACF,CACF,EAAGsF,CAAe,CACpB,CAAC,CACH,MAAY,CACV,WAAK,qBAAuB,KAC5B,KAAK,iBAAmB,OAGtB,KAAK,kBACL,6DAEJ,CACF,CAEA,MAAc,iBAAiB,CAC7B,SAAA/G,EACA,cAAA6C,EACA,iBAAA2E,EACA,IAAArG,CACF,EAK+B,CAC7B,OAAQ,MAAMI,EACZ,CAAC,CAAE,QAAAC,EAAS,OAAAC,EAAQ,WAAAgG,CAAW,IAAM,CACnC,IAAM1E,EAAY,MAAM,QAAQ/C,CAAQ,EAAIA,EAAW,CAACA,CAAQ,EAC1DiD,EAAwB,KAAK,cAAc,OAAQC,GACvDH,EAAU,SAASG,EAAI,QAAQ,CACjC,EAEA,GAAI,KAAK,aAAc,CACrB,IAAMwE,EAAU,KAAK,aACrB,YAAK,aAAe,OAEpB,cAAcD,CAAU,EACxBhG,IAAiBiG,CAAO,EACjB,EACT,SAESzE,EAAsB,QAAUJ,EAEvC,qBAAc4E,CAAU,EACxB,KAAK,cAAgB,KAAK,cAAc,OACrCvE,GAAQ,CAACH,EAAU,SAASG,EAAI,QAAQ,CAC3C,EACA1B,EAAkB,CAAC,GAAGyB,CAAqB,EAAE,MAAM,EAAGJ,CAAa,CAAC,EAC7D,EAGX,EACA,CACE,SAAU,iBACV,iBAAA2E,EACA,gBAAiB,KAAK,gBACxB,CACF,CACF,CASQ,uBAAuB,CAC7B,UAAAzE,EACA,MAAAL,CACF,EAGG,CACD,IAAMO,EAAwB,KAAK,cAAc,OAAQC,GACvDH,EAAU,SAASG,EAAI,QAAQ,CACjC,EACA,GAAID,EAAsB,OAAS,EACjC,YAAK,cAAgB,KAAK,cAAc,OACrCC,GAAQ,CAACH,EAAU,SAASG,EAAI,QAAQ,CAC3C,EACOD,EAEP,MAAMP,CAEV,CAWF,ECv2CA,IAAAiF,GAAkC,WAGrBC,EAAN,cAA4BC,CAAY,CAC7C,YAAYC,EAAwB,CAClC,GAAM,CAAE,gBAAAC,EAAiB,GAAGC,CAAK,EAAIF,EAErC,MAAME,CAAI,EACV,KAAK,IAAM,IAAK,GAAAC,QACd,KAAK,IACP,EACA,KAAK,QAAQ,CACf,CACF,ECZA,OAAOC,OAAe,KAQf,IAAMC,EAAN,cAA4BC,CAAY,CAO7C,YAAYC,EAAwB,CAClC,MAAMA,CAAK,EAPb,mBAAyB,GACzB,gBAAoB,CAAC,EACrB,6BAAsC,KAuGtC,KAAU,KAAQC,GAAgB,CAChC,KAAK,IAAI,KAAK,KAAK,UAAU,CAACA,CAAG,CAAC,CAAC,CACrC,EAgBA,KAAU,gBAAkB,IAAM,CAC5B,KAAK,MACP,KAAK,WAAW,QAASC,GAAS,CAChCA,GAAM,UAAU,CAClB,CAAC,EACD,KAAK,IAAI,mBAAmB,EACxB,KAAK,IAAI,aAAe,IAC1B,KAAK,IAAI,UAAU,EACnB,KAAK,IAAI,MAAM,GAGjB,KAAK,IAAM,KACX,KAAK,WAAa,CAAC,EAEvB,EAhIE,KAAK,SAAW,SAChB,KAAK,QAAQ,CACf,CA6BA,MAAgB,SAAU,CACnB,KAAK,OAEV,KAAK,gBAAgB,EAErB,KAAK,IAAM,IAAIC,GAAU,KAAK,KAAM,CAClC,kBAAmB,EACrB,CAAC,EAID,KAAK,IAAI,GAAG,QAAS,IAAM,CAAC,CAAC,EAC7B,KAAK,IAAI,GAAG,QAAS,IAAM,CACzB,KAAK,YAAY,CACnB,CAAC,EAED,KAAK,IAAI,GAAG,OAAQ,IAAM,CACpB,KAAK,yBACP,cAAc,KAAK,uBAAuB,EAExC,KAAK,wBAA0B,KAAK,sBAAsB,EAC5D,KAAK,KAAK,CACR,0BACA,OAAQ,KAAK,QACb,sBAAuB,KAAK,sBAC9B,CAAC,EAEG,KAAK,sBAAsB,GAC7B,KAAK,KAAK,CACR,OAAQ,KAAK,QACb,yBACF,CAAC,EAIL,KAAK,YAAY,CACf,0BACA,IAAMC,GAAM,CACV,GAAIA,GAAG,MAAO,CACZ,KAAK,iBAAmBA,EACxB,MACF,CACA,KAAK,uBACHA,GAAI,iBAA4B,CAAC,GAAG,sBACtC,KAAK,iBAAmB,MAC1B,CACF,CAAC,CACH,CAAC,EAED,KAAK,IAAI,GAAG,UAAW,CAAC,EAAQC,IAAkB,CAChD,IAAMC,EAAOD,EAAW,EAAI,GAAG,SAAS,EACxC,GAAI,CAACC,EAAM,OACX,IAAMF,EAAI,KAAK,MAAME,CAAI,EAIzB,KAAK,WAAW,QAASC,GAAQ,CAChBA,EAAI,SAASH,CAAC,CAI/B,CAAC,CACH,CAAC,EACH,CAMU,aAAc,CAClB,KAAK,gBAAgB,IAGrB,KAAK,yBACP,cAAc,KAAK,uBAAuB,EAGxC,KAAK,kBACP,WAAW,IAAM,KAAK,QAAQ,EAAG,GAAI,EAGzC,CAkBU,WAAY,CACpB,aAAa,KAAK,YAAY,EAE9B,KAAK,aAAe,WAAW,IAAM,CAC/B,KAAK,sBAAsB,GAC7B,KAAK,KAAK,CAAE,KAAM,EAAK,CAAC,CAE5B,EAAG,GAAI,CACT,CAGF,EC7JA,IAAII,GAEA,OAAO,OAAW,IACpBA,GAAUC,EAEVD,GAAUE","names":["require_reconnect","__commonJSMin","exports","module","isWebSocket","constructor","isGlobalWebSocket","getDefaultOptions","bypassProperty","src","dst","name","value","initReconnectionDelay","config","updateReconnectionDelay","previousDelay","newDelay","LEVEL_0_EVENTS","reassignEventListeners","ws","oldWs","listeners","type","listener","options","ReconnectingWebsocket","url","protocols","connectingTimeout","reconnectDelay","retriesCount","shouldRetry","key","log","params","emitError","code","msg","err","fn","handleClose","connect","reason","keepClosed","fastClose","delay","fakeCloseEvent","data","l","Environment","SdkType","ETaskType","EControlMode","EPreProcessorGroup","EPreProcessor","EOpenPosePreProcessor","EModelFormat","EModelArchitecture","EModelType","EModelConditioning","EPhotoMakerEnum","uuidv4","validateUUID","TIMEOUT_DURATION","MINIMUM_TIMEOUT_DURATION","POLLING_INTERVAL","BASE_RUNWARE_URLS","removeFromAray","col","targetElem","i","getIntervalWithPromise","callback","debugKey","timeoutDuration","shouldThrowError","resolve","reject","timeoutId","intervalId","fileToBase64","file","reader","getUUID","isValidUUID","uuid","accessDeepObject","key","data","useZero","shouldReturnString","acc","curr","returnZero","currentValue","index","delay","time","milliseconds","resolve","removeListener","listeners","listener","lis","evaluateNonTrue","key","value","getRandomNumber","min","max","getRandomSeed","asyncRetry","apiCall","options","delayInSeconds","callback","maxRetries","error","delay","RunwareBase","apiKey","url","BASE_RUNWARE_URLS","shouldReconnect","globalMaxRetries","timeoutDuration","TIMEOUT_DURATION","msg","file","asyncRetry","taskUUID","getUUID","isValidUUID","imageBase64","fileToBase64","inputImage","preProcessorType","height","width","outputType","outputFormat","highThresholdCanny","lowThresholdCanny","includeHandsAndFaceOpenPose","includeCost","outputQuality","customTaskUUID","retry","totalRetry","lis","image","evaluateNonTrue","guideImage","getIntervalWithPromise","resolve","reject","uploadedImage","e","imageUploaded","response","newReverseClip","payload","upscaleFactor","newUpscaleGan","prompt","promptMaxLength","promptVersions","reducedPrompt","onUploadStream","addModelPayload","result","errorResult","error","moreOptions","onPartialImages","numberResults","photoMakerPayload","taskUUIDs","retryCount","imagesWithSimilarTask","img","imageRemaining","getRandomSeed","promise","debugKey","restPayload","value","errorValue","props","instance","groupKey","listener","arrayMessage","arrayErrors","filteredMessage","v","groupListener","removeListener","m","data","removeFromAray","positivePrompt","negativePrompt","images","accessDeepObject","uploadEndpoint","checkNSFW","seedImage","maskImage","strength","model","steps","scheduler","seed","CFGScale","clipSkip","usePromptWeighting","promptWeighting","refiner","maskMargin","controlNet","lora","embeddings","ipAdapters","outpaint","requestObject","seedImageUUID","maskImageUUID","controlNetData","uploadedMaskInitiator","i","controlData","endStep","startStep","weight","controlMode","startStepPercentage","endStepPercentage","controlNetModel","newRequestObject","retryInterval","pollingInterval","MAX_RETRY","localConnectionUUID","retryIntervalId","pollingIntervalId","clearAllIntervals","hasConnected","shouldCallServer","SHOULD_RETRY","shouldThrowError","intervalId","newData","import_reconnect","RunwareClient","RunwareBase","props","shouldReconnect","rest","ReconnectingWebsocket","WebSocket","RunwareServer","RunwareBase","props","msg","list","WebSocket","m","isBinary","data","lis","Runware","RunwareServer","RunwareClient"]}