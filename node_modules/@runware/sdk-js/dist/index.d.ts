declare enum Environment {
    PRODUCTION = "PRODUCTION",
    DEVELOPMENT = "DEVELOPMENT",
    TEST = "TEST"
}
declare enum SdkType {
    CLIENT = "CLIENT",
    SERVER = "SERVER"
}
declare enum ETaskType {
    IMAGE_INFERENCE = "imageInference",
    IMAGE_UPLOAD = "imageUpload",
    IMAGE_UPSCALE = "imageUpscale",
    IMAGE_BACKGROUND_REMOVAL = "imageBackgroundRemoval",
    PHOTO_MAKER = "photoMaker",
    IMAGE_CAPTION = "imageCaption",
    IMAGE_CONTROL_NET_PRE_PROCESS = "imageControlNetPreProcess",
    IMAGE_MASKING = "imageMasking",
    PROMPT_ENHANCE = "promptEnhance",
    AUTHENTICATION = "authentication",
    MODEL_UPLOAD = "modelUpload",
    MODEL_SEARCH = "modelSearch"
}
type RunwareBaseType = {
    apiKey: string;
    url?: string;
    shouldReconnect?: boolean;
    globalMaxRetries?: number;
    timeoutDuration?: number;
};
type IOutputType = "base64Data" | "dataURI" | "URL";
type IOutputFormat = "JPG" | "PNG" | "WEBP";
interface IImage {
    taskType: ETaskType;
    imageUUID: string;
    inputImageUUID?: string;
    taskUUID: string;
    imageURL?: string;
    imageBase64Data?: string;
    imageDataURI?: string;
    NSFWContent?: boolean;
    cost?: number;
    seed: number;
}
interface ITextToImage extends IImage {
    positivePrompt?: string;
    negativePrompt?: string;
}
interface IControlNetImage {
    taskUUID: string;
    inputImageUUID: string;
    guideImageUUID: string;
    guideImageURL?: string;
    guideImageBase64Data?: string;
    guideImageDataURI?: string;
    cost?: number;
}
interface ILora {
    model: string | number;
    weight: number;
}
declare enum EControlMode {
    BALANCED = "balanced",
    PROMPT = "prompt",
    CONTROL_NET = "controlnet"
}
type IControlNetGeneral = {
    model: string;
    guideImage: string | File;
    weight?: number;
    startStep?: number;
    startStepPercentage?: number;
    endStep?: number;
    endStepPercentage?: number;
    controlMode: EControlMode;
};
type IControlNetPreprocess = {
    inputImage: string | File;
    preProcessorType: EPreProcessorGroup;
    height?: number;
    width?: number;
    outputType?: IOutputType;
    outputFormat?: IOutputFormat;
    highThresholdCanny?: number;
    lowThresholdCanny?: number;
    includeHandsAndFaceOpenPose?: boolean;
    includeCost?: boolean;
    outputQuality?: number;
    customTaskUUID?: string;
    retry?: number;
};
type IControlNet = IControlNetGeneral;
type IControlNetWithUUID = Omit<IControlNet, "guideImage"> & {
    guideImage?: string;
};
interface IError {
    error: boolean;
    errorMessage: string;
    taskUUID: string;
}
type TPromptWeighting = "compel" | "sdEmbeds";
interface IRequestImage {
    outputType?: IOutputType;
    outputFormat?: IOutputFormat;
    uploadEndpoint?: string;
    checkNSFW?: boolean;
    positivePrompt: string;
    negativePrompt?: string;
    seedImage?: File | string;
    maskImage?: File | string;
    strength?: number;
    height?: number;
    width?: number;
    model: number | string;
    steps?: number;
    scheduler?: string;
    seed?: number;
    maskMargin?: number;
    CFGScale?: number;
    clipSkip?: number;
    /**
     * @deprecated The usePromptWeighting should not be used, use promptWeighting instead
     */
    usePromptWeighting?: boolean;
    promptWeighting?: TPromptWeighting;
    numberResults?: number;
    includeCost?: boolean;
    outputQuality?: number;
    controlNet?: IControlNet[];
    lora?: ILora[];
    embeddings?: IEmbedding[];
    ipAdapters?: IipAdapter[];
    outpaint?: IOutpaint;
    refiner?: IRefiner;
    customTaskUUID?: string;
    onPartialImages?: (images: IImage[], error?: IError) => void;
    retry?: number;
}
interface IOutpaint {
    top?: number;
    bottom?: number;
    right?: number;
    left?: number;
    blur?: number;
}
interface IEmbedding {
    model: string;
    weight: number;
}
interface IipAdapter {
    model: string;
    weight: number;
    guideImage: string;
}
interface IRefiner {
    model: string;
    startStep?: number;
    startStepPercentage?: number;
}
interface IRequestImageToText {
    inputImage?: File | string;
    includeCost?: boolean;
    customTaskUUID?: string;
    retry?: number;
}
interface IImageToText {
    taskType: ETaskType;
    taskUUID: string;
    text: string;
    cost?: number;
}
interface IRemoveImageBackground extends IRequestImageToText {
    outputType?: IOutputType;
    outputFormat?: IOutputFormat;
    model: string;
    settings?: {
        rgba?: number[];
        postProcessMask?: boolean;
        returnOnlyMask?: boolean;
        alphaMatting?: boolean;
        alphaMattingForegroundThreshold?: number;
        alphaMattingBackgroundThreshold?: number;
        alphaMattingErodeSize?: number;
    };
    includeCost?: boolean;
    outputQuality?: number;
    retry?: number;
}
interface IRemoveImage {
    taskType: ETaskType;
    taskUUID: string;
    imageUUID: string;
    inputImageUUID: string;
    imageURL?: string;
    imageBase64Data?: string;
    imageDataURI?: string;
    cost?: number;
}
interface IPromptEnhancer {
    promptMaxLength?: number;
    promptVersions?: number;
    prompt: string;
    includeCost?: boolean;
    customTaskUUID?: string;
    retry?: number;
}
interface IEnhancedPrompt extends IImageToText {
}
interface IUpscaleGan {
    inputImage: File | string;
    upscaleFactor: number;
    outputType?: IOutputType;
    outputFormat?: IOutputFormat;
    includeCost?: boolean;
    outputQuality?: number;
    customTaskUUID?: string;
    retry?: number;
}
type ReconnectingWebsocketProps = {
    addEventListener: (type: string, listener: EventListener, options: any) => void;
    send: (data: any) => void;
} & WebSocket;
type UploadImageType = {
    imageURL: string;
    imageUUID: string;
    taskUUID: string;
    taskType: ETaskType;
};
type GetWithPromiseCallBackType = ({ resolve, reject, intervalId, }: {
    resolve: <T>(value: T) => void;
    reject: <T>(value: T) => void;
    intervalId: any;
}) => boolean | undefined;
declare enum EPreProcessorGroup {
    "canny" = "canny",
    "depth" = "depth",
    "mlsd" = "mlsd",
    "normalbae" = "normalbae",
    "openpose" = "openpose",
    "tile" = "tile",
    "seg" = "seg",
    "lineart" = "lineart",
    "lineart_anime" = "lineart_anime",
    "shuffle" = "shuffle",
    "scribble" = "scribble",
    "softedge" = "softedge"
}
declare enum EPreProcessor {
    "canny" = "canny",
    "depth_leres" = "depth_leres",
    "depth_midas" = "depth_midas",
    "depth_zoe" = "depth_zoe",
    "inpaint_global_harmonious" = "inpaint_global_harmonious",
    "lineart_anime" = "lineart_anime",
    "lineart_coarse" = "lineart_coarse",
    "lineart_realistic" = "lineart_realistic",
    "lineart_standard" = "lineart_standard",
    "mlsd" = "mlsd",
    "normal_bae" = "normal_bae",
    "scribble_hed" = "scribble_hed",
    "scribble_pidinet" = "scribble_pidinet",
    "seg_ofade20k" = "seg_ofade20k",
    "seg_ofcoco" = "seg_ofcoco",
    "seg_ufade20k" = "seg_ufade20k",
    "shuffle" = "shuffle",
    "softedge_hed" = "softedge_hed",
    "softedge_hedsafe" = "softedge_hedsafe",
    "softedge_pidinet" = "softedge_pidinet",
    "softedge_pidisafe" = "softedge_pidisafe",
    "tile_gaussian" = "tile_gaussian",
    "openpose" = "openpose",
    "openpose_face" = "openpose_face",
    "openpose_faceonly" = "openpose_faceonly",
    "openpose_full" = "openpose_full",
    "openpose_hand" = "openpose_hand"
}
declare enum EOpenPosePreProcessor {
    "openpose" = "openpose",
    "openpose_face" = "openpose_face",
    "openpose_faceonly" = "openpose_faceonly",
    "openpose_full" = "openpose_full",
    "openpose_hand" = "openpose_hand"
}
type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> & {
    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;
}[Keys];
type RequireOnlyOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> & {
    [K in Keys]-?: Required<Pick<T, K>> & Partial<Record<Exclude<Keys, K>, undefined>>;
}[Keys];
type ListenerType = {
    key: string;
    listener: (msg: any) => void;
    groupKey?: string;
};
interface IAddModelResponse {
    status: string;
    message: string;
    taskUUID: string;
    air: string;
    taskType: string;
}
interface IErrorResponse {
    code: string;
    message: string;
    parameter: string;
    type: string;
    documentation: string;
    taskUUID: string;
    min?: number;
    max?: number;
    default?: string | number;
}
type TAddModelBaseType = {
    air: string;
    name: string;
    downloadUrl: string;
    uniqueIdentifier: string;
    version: string;
    format: EModelFormat;
    architecture: EModelArchitecture;
    heroImageUrl?: string;
    tags?: string[];
    shortDescription?: string;
    comment?: string;
    private: boolean;
    customTaskUUID?: string;
    retry?: number;
    onUploadStream?: (response?: IAddModelResponse, error?: IErrorResponse) => void;
};
type TAddModelControlNet = {
    category: "controlnet";
    conditioning: EModelConditioning;
} & TAddModelBaseType;
type TAddModelCheckPoint = {
    category: "checkpoint";
    defaultCFGScale?: number;
    defaultStrength: number;
    defaultSteps?: number;
    defaultScheduler?: string;
    type: EModelType;
} & TAddModelBaseType;
type TAddModelLora = {
    category: "lora";
    defaultWeight: number;
    positiveTriggerWords?: string;
} & TAddModelBaseType;
type TAddModel = TAddModelCheckPoint | TAddModelControlNet | TAddModelLora;
type TPhotoMaker = {
    style: EPhotoMakerEnum;
    inputImages: string[];
    outputType?: string;
    outputFormat?: string;
    uploadEndpoint?: string;
    checkNSFW?: boolean;
    positivePrompt: string;
    negativePrompt?: string;
    strength?: number;
    height: number;
    width: number;
    model?: string;
    steps?: number;
    scheduler?: string;
    seed?: number;
    CFGScale?: number;
    clipSkip?: number;
    numberResults: number;
    includeCost?: boolean;
    outputQuality?: number;
    customTaskUUID?: string;
    retry?: number;
    onPartialImages?: (images: IImage[], error?: IError) => void;
};
type TPhotoMakerResponse = {
    taskType: string;
    taskUUID: string;
    imageUUID: string;
    NSFWContent: boolean;
    cost: number;
    seed: number;
    imageURL: string;
    positivePrompt: string;
    negativePrompt?: string;
};
declare enum EModelFormat {
    safetensors = "safetensors",
    pickletensor = "pickletensor"
}
declare enum EModelArchitecture {
    flux1d = "flux1d",
    flux1s = "flux1s",
    pony = "pony",
    sdhyper = "sdhyper",
    sd1x = "sd1x",
    sd1xlcm = "sd1xlcm",
    sd3 = "sd3",
    sdxl = "sdxl",
    sdxllcm = "sdxllcm",
    sdxldistilled = "sdxldistilled",
    sdxlhyper = "sdxlhyper",
    sdxllightning = "sdxllightning",
    sdxlturbo = "sdxlturbo"
}
declare enum EModelType {
    base = "base",
    inpainting = "inpainting",
    pix2pix = "pix2pix"
}
declare enum EModelConditioning {
    canny = "canny",
    depth = "depth",
    qrcode = "qrcode",
    hed = "hed",
    scrible = "scrible",
    openpose = "openpose",
    seg = "segmentation",
    openmlsd = "openmlsd",
    softedge = "softedge",
    normal = "normal bae",
    shuffle = "shuffle",
    pix2pix = "pix2pix",
    inpaint = "inpaint",
    lineart = "line art",
    sketch = "sketch",
    inpaintdepth = "inpaint depth",
    tile = "tile",
    outfit = "outfit",
    blur = "blur",
    gray = "gray",
    lowquality = "low quality"
}
declare enum EPhotoMakerEnum {
    NoStyle = "No style",
    Cinematic = "Cinematic",
    DisneyCharacter = "Disney Character",
    DigitalArt = "Digital Art",
    Photographic = "Photographic",
    FantasyArt = "Fantasy art",
    Neonpunk = "Neonpunk",
    Enhance = "Enhance",
    ComicBook = "Comic book",
    Lowpoly = "Lowpoly",
    LineArt = "Line art"
}
type TModelSearch = {
    search?: string;
    tags?: string[];
    category?: "checkpoint" | "lora" | "controlnet";
    type?: string;
    architecture?: EModelArchitecture;
    conditioning?: string;
    visibility?: "public" | "private" | "all";
    limit?: number;
    offset?: number;
    customTaskUUID?: string;
    retry?: number;
} & {
    [key: string]: any;
};
type TModel = {
    air: string;
    name: string;
    version: string;
    category: string;
    architecture: string;
    tags: string[];
    heroImage: string;
    private: boolean;
    comment: string;
    type?: string;
    defaultWidth?: number;
    defaultHeight?: number;
    defaultSteps?: number;
    defaultScheduler?: string;
    defaultCFG?: number;
    defaultStrength: number;
    conditioning?: string;
    positiveTriggerWords?: string;
} & {
    [key: string]: any;
};
type TModelSearchResponse = {
    results: TModel[];
    taskUUID: string;
    taskType: string;
    totalResults: number;
};
type TImageMasking = {
    model: string;
    inputImage: string;
    confidence?: number;
    maskPadding?: number;
    maskBlur?: number;
    outputFormat?: string;
    outputType?: string;
    includeCost?: boolean;
    uploadEndpoint?: string;
    maxDetections?: number;
    outputQuality?: number;
    customTaskUUID?: string;
    retry?: number;
};
type TImageMaskingResponse = {
    taskType: string;
    taskUUID: string;
    maskImageUUID: string;
    detections: [
        {
            x_min: number;
            y_min: number;
            x_max: number;
            y_max: number;
        }
    ];
    maskImageURL: string;
    cost: number;
};
type TServerError = {
    error: {
        code: string;
        message: string;
        parameter: string;
        type: string;
        taskType: string;
    };
};

declare class RunwareBase {
    _ws: ReconnectingWebsocketProps | any;
    _listeners: ListenerType[];
    _apiKey: string;
    _url?: string;
    _globalMessages: Record<string, any>;
    _globalImages: IImage[];
    _globalError: IError | undefined;
    _connectionSessionUUID: string | undefined;
    _connectionError: TServerError | undefined;
    _sdkType: SdkType;
    _shouldReconnect: boolean;
    _globalMaxRetries: number;
    _timeoutDuration: number;
    ensureConnectionUUID: string | null;
    constructor({ apiKey, url, shouldReconnect, globalMaxRetries, timeoutDuration, }: RunwareBaseType);
    static initialize(props: RunwareBaseType): Promise<RunwareBase>;
    protected isWebsocketReadyState: () => boolean;
    protected isInvalidAPIKey: () => boolean;
    protected addListener({ lis, groupKey, taskUUID, }: {
        lis: (v: any) => any;
        groupKey?: string;
        taskUUID: string;
    }): {
        destroy: () => void;
    };
    protected connect(): void;
    protected send: (msg: Object) => void;
    private destroy;
    private uploadImage;
    private listenToImages;
    private listenToUpload;
    private globalListener;
    requestImages({ outputType, outputFormat, uploadEndpoint, checkNSFW, positivePrompt, negativePrompt, seedImage, maskImage, strength, height, width, model, steps, scheduler, seed, CFGScale, clipSkip, usePromptWeighting, promptWeighting, numberResults, onPartialImages, includeCost, customTaskUUID, retry, refiner, maskMargin, outputQuality, controlNet, lora, embeddings, ipAdapters, outpaint, }: IRequestImage, moreOptions?: Record<string, any>): Promise<ITextToImage[] | undefined>;
    controlNetPreProcess: ({ inputImage, preProcessorType, height, width, outputType, outputFormat, highThresholdCanny, lowThresholdCanny, includeHandsAndFaceOpenPose, includeCost, outputQuality, customTaskUUID, retry, }: IControlNetPreprocess) => Promise<IControlNetImage | null>;
    requestImageToText: ({ inputImage, includeCost, customTaskUUID, retry, }: IRequestImageToText) => Promise<IImageToText>;
    removeImageBackground: (payload: IRemoveImageBackground) => Promise<IRemoveImage>;
    upscaleGan: ({ inputImage, upscaleFactor, outputType, outputFormat, includeCost, outputQuality, customTaskUUID, retry, }: IUpscaleGan) => Promise<IImage>;
    enhancePrompt: ({ prompt, promptMaxLength, promptVersions, includeCost, customTaskUUID, retry, }: IPromptEnhancer) => Promise<IEnhancedPrompt[]>;
    modelUpload: (payload: TAddModel) => Promise<any>;
    photoMaker: (payload: TPhotoMaker, moreOptions?: Record<string, any>) => Promise<TPhotoMakerResponse[] | undefined>;
    modelSearch: (payload: TModelSearch) => Promise<TModelSearchResponse>;
    imageMasking: (payload: TImageMasking) => Promise<TImageMaskingResponse>;
    protected baseSingleRequest: <T>({ payload, debugKey, }: {
        payload: Record<string, any>;
        debugKey: string;
    }) => Promise<T>;
    ensureConnection(): Promise<unknown>;
    private getSimilarImages;
    private getSingleMessage;
    private handleIncompleteImages;
    disconnect: () => Promise<void>;
    private connected;
}

declare class RunwareClient extends RunwareBase {
    constructor(props: RunwareBaseType);
}

declare class RunwareServer extends RunwareBase {
    _instantiated: boolean;
    _listeners: any[];
    _reconnectingIntervalId: null | any;
    _pingTimeout: any;
    _pongListener: any;
    constructor(props: RunwareBaseType);
    protected connect(): Promise<void>;
    protected send: (msg: Object) => void;
    protected handleClose(): void;
    protected resetConnection: () => void;
    protected heartBeat(): void;
}

declare let Runware: typeof RunwareClient | typeof RunwareServer;

export { EControlMode, EModelArchitecture, EModelConditioning, EModelFormat, EModelType, EOpenPosePreProcessor, EPhotoMakerEnum, EPreProcessor, EPreProcessorGroup, ETaskType, Environment, type GetWithPromiseCallBackType, type IAddModelResponse, type IControlNet, type IControlNetGeneral, type IControlNetImage, type IControlNetPreprocess, type IControlNetWithUUID, type IEmbedding, type IEnhancedPrompt, type IError, type IErrorResponse, type IImage, type IImageToText, type IOutpaint, type IOutputFormat, type IOutputType, type IPromptEnhancer, type IRefiner, type IRemoveImage, type IRemoveImageBackground, type IRequestImage, type IRequestImageToText, type ITextToImage, type IUpscaleGan, type IipAdapter, type ListenerType, type ReconnectingWebsocketProps, type RequireAtLeastOne, type RequireOnlyOne, Runware, type RunwareBaseType, RunwareClient, RunwareServer, SdkType, type TAddModel, type TAddModelBaseType, type TAddModelCheckPoint, type TAddModelControlNet, type TAddModelLora, type TImageMasking, type TImageMaskingResponse, type TModel, type TModelSearch, type TModelSearchResponse, type TPhotoMaker, type TPhotoMakerResponse, type TPromptWeighting, type TServerError, type UploadImageType };
